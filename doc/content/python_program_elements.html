<!DOCTYPE html>
<html>
<head><title>Элементы программы на языке Python</title>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/png" href="../pict/favicon.png"/>
<link rel="stylesheet" type="text/css" href="../layout/styles.css"/>
<link rel="stylesheet" type="text/css" href="../layout/layout.css"/>
<link rel="stylesheet" type="text/css" href="../theme.css"/>

<style>
.headerNavArrows {position: relative; top: 3px;}
</style>
</head>
<body>

<div class="header"><b><span style="color:#59f;margin-right:7px;">Py</span></b><a 
class="header_item" href="index_page.html">Index</a><a 
class="header_item" href="todo_page.html">TODO</a><a 
class="header_item" href="problems_page.html">Задачи</a><a 
class="header_item" href="https://github.com/mycatislovely/python_study">GitHub</a>

<a href="../../doc_src/python_program_elements.txt " class="header_item_source" title="Source text">&lt;/&gt;</a>


<a href="python_working_environment.html" title="Previous: Рабочая среда Python"><img class="headerNavArrows" src="../layout/pict/previous_page_h18px.png"/></a>

<a href="programming_techniques.html" title="Next: Приемы программирования"><img class="headerNavArrows" src="../layout/pict/next_page_h18px.png"/></a>


<span class="headerTitle">Элементы программы на языке Python</span>

</div>

<div class="sidebar">
    <table class="sidebarAligner">
        <tr><td valign="top">
            <a class="sidebar_item" href="about.html">Введение</a>
<a class="sidebar_item" href="architecture.html">Основы программирования</a>
<a class="sidebar_item" href="program_design.html">Проектирование программ</a>
<a class="sidebar_item" href="command_line_work.html">Работа в командной строке</a>
<a class="sidebar_item" href="related_technologies.html">Сопутствующие технологии</a>
<a class="sidebar_item" href="python_working_environment.html">Рабочая среда Python</a>
<a class="sidebar_item selected" href="python_program_elements.html">Элементы программы на языке Python</a>
<a class="sidebar_item" href="programming_techniques.html">Приемы программирования</a>
<a class="sidebar_item" href="algorithms_and_data_structures.html">Алгоритмы и структуры данных</a>
<a class="sidebar_item" href="web_programming.html">Веб-программирование</a>
<a class="sidebar_item" href="technical_English.html">Technical English</a>
            <h3>Задачи</h3>
            <a class="sidebar_item" href="problems/01_12_intro.html">1 Основы</a>
<a class="sidebar_item" href="problems/2_lists.html">2 Циклы, строки, списки</a>
<a class="sidebar_item" href="problems/3_final_tasks.html">3 Итоговые задачи</a>
<a class="sidebar_item" href="problems/4_python_drill.html">4 Python drill</a>
<a class="sidebar_item" href="problems/5_chess.html">5 Шахматы</a>
<a class="sidebar_item" href="problems/mini_projects.html">6 Мини проекты</a>
            <h3>Useful links</h3>
            <a class="sidebar_item" href="https://www.python.org/">Python</a>
<a class="sidebar_item" href="https://git-scm.com/">Git</a>
        </td></tr>
        <tr><td class="bottom" valign="bottom">
            Generated by md2html_py 1.0.4
        </td></tr>
    </table>
</div>

<p style="font-size:44px;font-weight:bold;margin:0 0 30px 0;">Элементы программы на языке Python</p>

<div class="toc">
<ul>
<li><a href="#_1">Соглашение об оформлении кода</a></li>
<li><a href="#_2">Комментарии</a></li>
<li><a href="#_3">Типы данных и значения</a><ul>
<li><a href="#_4">Скалярные значения</a></li>
<li><a href="#_5">Комплексные значения</a></li>
<li><a href="#_6">Другие типы значений</a></li>
<li><a href="#_7">Определение типа значения</a></li>
<li><a href="#_8">Преобразование типов</a></li>
<li><a href="#_9">Приведение значений к логическому типу</a></li>
<li><a href="#_10">Интерпретация логических значений как чисел</a></li>
</ul>
</li>
<li><a href="#_11">Переменные</a><ul>
<li><a href="#_12">Имена переменных</a></li>
<li><a href="#_13">Использование переменных</a></li>
</ul>
</li>
<li><a href="#_14">Операции</a><ul>
<li><a href="#_15">Цепочка сравнений</a></li>
<li><a href="#_16">"Моржовый" оператор</a></li>
</ul>
</li>
<li><a href="#_17">Выражения</a></li>
<li><a href="#_18">Ветвление</a></li>
<li><a href="#_19">Циклы</a><ul>
<li><a href="#_20">Цикл по условию</a></li>
<li><a href="#_21">Цикл по счетчику</a></li>
<li><a href="#else">Блок else</a></li>
<li><a href="#c">Циклы c предусловием и постусловием</a></li>
</ul>
</li>
<li><a href="#_22">Итерируемые объекты</a></li>
<li><a href="#_23">Функция</a><ul>
<li><a href="#_24">Функции с переменным количеством аргументов</a></li>
<li><a href="#_25">Распаковка коллекций в аргументы при вызове функции</a></li>
</ul>
</li>
<li><a href="#_26">Коллекции</a><ul>
<li><a href="#_27">Массив</a><ul>
<li><a href="#_28">Вложенные списки или матрицы</a></li>
<li><a href="#_29">Ссылочная модель вложенных списков</a></li>
</ul>
</li>
<li><a href="#_30">Кортеж</a></li>
<li><a href="#_31">Словарь</a><ul>
<li><a href="#_32">Поиск по ключу</a></li>
<li><a href="#_33">Удаление элемента</a></li>
<li><a href="#_34">Добавление элемента</a></li>
<li><a href="#_35">Изменение элемента</a></li>
<li><a href="#_36">Итерация по словарю</a></li>
<li><a href="#_37">Методы словаря</a></li>
</ul>
</li>
<li><a href="#_38">Множества</a></li>
<li><a href="#_39">Генерация коллекций</a><ul>
<li><a href="#_40">Генерация коллекций с вложенным циклом</a></li>
<li><a href="#_41">Анонимный генератор</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_42">Модуль</a></li>
<li><a href="#_43">Объекты и классы</a></li>
<li><a href="#_44">Обработка ошибок</a></li>
<li><a href="#_45">Отступы</a></li>
<li><a href="#_46">Методы строк</a><ul>
<li><a href="#_47">Поиск и замена</a></li>
<li><a href="#_48">Регулярные выражения</a></li>
</ul>
</li>
</ul>
</div>
<hr />
<p><a name="index_entry_i_1"></a></p>
<h1 id="_1">Соглашение об оформлении кода</h1>
<p>Язык Python предъявляет достаточно жесткие требования к оформлению программного кода, однако
все равно вариантов написания может быть достаточно много, и это может вызвать проблемы в понимании 
кода разными программистами. Для повышения степени единообразия кода были разработаны соглашения,
которые предъявляют дополнительные требования к оформлению кода. Несоблюдение этих требований не 
приведет к ошибке при выполнении программы, однако их соблюдение сделает код более единообразным и,
следовательно, более понятным для всех. </p>
<p>См. <a href="https://peps.python.org/pep-0008/">PEP 8 – Style Guide for Python Code</a>.</p>
<hr />
<p><a name="index_entry_i_2"></a></p>
<h1 id="_2">Комментарии</h1>
<p>Комментарий начинается с символа <code>#</code>, они игнорируются интерпретатором и нужны для пояснения 
программистам или тем, кто читает код:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; print("Hello, world!")  # этот текст будет проигнорирован
Hello, world!</code></pre>
<hr />
<h1 id="_3">Типы данных и значения</h1>
<p><a name="index_entry_i_3"></a>
<strong>Значение</strong> &mdash; это элемент данных, которым манипулирует программа. Любое значение каким-то 
образом представлено в памяти. В программе они указываются непосредственно (в виде <em>литералов</em>) 
или появляются в результате вычислений (вычисления будет рассмотрены позже).</p>
<p>В языке программирования каждое значение как правило имеет определенный тип, который определяет 
способ интерпретации соответствующей области памяти, а также набор доступных операций над этим 
значением. Набор всех возможных значений данных называется набором <strong>типов данных</strong> языка. </p>
<p>Далее будут рассмотрены различные типы данных языка Python.</p>
<p><a name="index_entry_i_4"></a></p>
<h2 id="_4">Скалярные значения</h2>
<p><strong>Скалярные значения</strong> &mdash; это такие значения, которые воспринимаются как единичные, т.е. неделимые.
Рассмотрим основные типы таких значений. </p>
<p><a name="index_entry_i_5"></a>
<strong>Числовые значения:</strong></p>
<ul>
<li><code>int</code> &mdash; целые числа, например: <code>20</code>, <code>-5</code>;</li>
<li><code>float</code> &mdash; числа с плавающей точкой (дробные), например: <code>2.5</code>, <code>2.5e2</code> 
    (2,5 * 10<sup>2</sup> = 250). </li>
</ul>
<p><a name="index_entry_i_6"></a>
<strong>Логические значения.</strong>
Имеются только два логических значения: <code>True</code> и <code>False</code>, т.е. "истина" и "ложь". </p>
<p><a name="index_entry_i_7"></a>
<strong>Пустое значение.</strong> Этот тип данных имеет только одно значение, <code>None</code>, которое используется 
для указания на то, что значение отсутствует или не может быть определено.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Пустые значения подобные None присутствуют и в других языках программирования. Например, в языке
Джава типом переменной может быть "строка", и эта переменная может иметь значение
(<code>nole</code>), при этом тип все равно будет строка. В Puthon None это отдельный тип.</p>
</div>
<p><a name="index_entry_i_8"></a></p>
<h2 id="_5">Комплексные значения</h2>
<p><strong>Комплексные значения</strong> &mdash; это такие значения, которые предполагают дальнейшее деление на
составляющие значения, которые могут быть как комплексными, так и скалярными. К комплексным типам
данных относятся:</p>
<p><a name="index_entry_i_9"></a>
- <strong>строка</strong> &mdash; последовательность символов. В программном коде задаются литералами с 
    использованием одинарных либо двойных кавычек, например: <code>"a"</code>, <code>"b"</code>, <code>"23"</code>, <code>'A, "Z", s'</code>, 
    <code>"A, 'Z', s"</code>. 
    В строке могут использоваться специальные последовательности: 
    - <code>\"</code>: <code>"Ф, П, \"р\", т"</code> &mdash; двойная кавычка внутри строки;
    - <code>\'</code>: <code>'Ф, П, \'р\', т'</code> &mdash; одинарная кавычка внутри строки;
    - <code>\\</code> &mdash; один слеш;
    - <code>\n</code> &mdash; перевод строки.
<a name="index_entry_i_10"></a>
- <strong>коллекции</strong> &mdash; это комплексные значения, которые содержат изначально неопределенное количество
    других значений. К ним относятся:
    - списки
    - кортежи
    - словари
    - множества
    - строки, которые тоже можно рассматривать как коллекции, однако ввиду их особой важности они 
        были вынесены в отдельный пункт.      <br />
- <a href="#classes">классы</a> &mdash; составной тип данных с предопределенной структурой.</p>
<p>Более подробно эти типы данных будут рассмотрены в отдельных разделах.</p>
<h2 id="_6">Другие типы значений</h2>
<p>Есть другие типы значений, например функции и генераторы. Они будут рассмотрены отдельно.</p>
<h2 id="_7">Определение типа значения</h2>
<p>Чтобы проверить тип любого объекта в Python, используется функция <code>type()</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; type(5)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(3.6)
&lt;class 'float'&gt;
&gt;&gt;&gt; type("demo")
&lt;class 'str'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(None)
&lt;class 'NoneType'&gt;
&gt;&gt;&gt; type([1, 2, 3])
&lt;class 'list'&gt;</code></pre>
<p><code>type()</code> здесь является примером использования функции. Функции мы рассмотрим позже. Также здесь 
приведен пример <em>список</em>, который также будет рассмотрен отдельно.</p>
<h2 id="_8">Преобразование типов</h2>
<p>Значение одних типов могут быть преобразованы в значения некоторых других типов, например:
число в строку, строка в число. Такое преобразование может выглядеть тривиальным, однако на самом 
деле значения различных типов имеют различные представления в памяти, поэтому преобразование
требует фактического пересчета бинарного представления значений. Например: строка <code>'1'</code> в 
однобайтной кодировке ASCII представляется как число 49<sub>10</sub> или 00110001<sub>2</sub>.
При этом число 1 представленное 1 байтом будет 00000001<sub>2</sub>. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>В языке Puthon для кодирования чисел и символов как правило используется больше одного байта. 
В приведенном выше примере для простоты использовалось представление размером в 1 байт. 
Этого достаточно для того, чтобы передать основную идею преобразования типов данных.</p>
</div>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; float(1)  # convert from int to float
1.0
&gt;&gt;&gt; int(2.8)  # convert from float to int
2
&gt;&gt;&gt; str(1)
'1'
&gt;&gt;&gt; int('2')
2</code></pre>
<p><a name="index_entry_i_11"></a></p>
<h2 id="_9">Приведение значений к логическому типу</h2>
<p>Конструкции языка Python, требующие для своей работы логических выражений/значений, такие как 
условия <code>if</code> и <code>while</code>, могут также принимать выражения/значения других типов, которые 
интерпретируются как логические. Например: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; if 1+1:
...     print('yes')
yes</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Условные оператор <code>if</code> и цикл <code>while</code> будут рассмотрены позже. Здесь важно понимать только то, 
что от выражения 1+1 ожидается логический результат.</p>
</div>
<p>Казалось бы, условному оператору требуется логический аргумент для принятия решения, однако в данном
примере мы видим, что в данном случае оператор <code>if</code> интерпретировал значение 2 как  <code>True</code>. Особенностью 
языка Python является то, что в нем значения разных типов могут приводиться к соответствующему
логическому значению. Основные правила таковы:</p>
<table>
<thead>
<tr>
<th>Тип</th>
<th>False</th>
<th>True</th>
</tr>
</thead>
<tbody>
<tr>
<td>число</td>
<td>0</td>
<td>все остальные</td>
</tr>
<tr>
<td>строка</td>
<td>пустая строка</td>
<td>не пустая строка</td>
</tr>
<tr>
<td>коллекция</td>
<td>пустая коллекция</td>
<td>не пустая коллекция</td>
</tr>
<tr>
<td>None</td>
<td>всегда</td>
<td>никогда</td>
</tr>
</tbody>
</table>
<p>По аналогии с функциями <code>int()</code> и <code>str()</code> есть функция <code>bool</code>, которая возвращает логическое 
представление значений различных типов. Рассмотрим примеры ее работы:</p>
<p><a name="index_entry_i_12"></a></p>
<table>
<thead>
<tr>
<th>Тип</th>
<th>Выражение</th>
<th>Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>число</td>
<td><code>bool(0)</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>число</td>
<td><code>bool(0.0000001)</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>число</td>
<td><code>bool(-1)</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('')</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('a')</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('0')</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('False')</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>логический</td>
<td><code>bool([False])</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>список *</td>
<td><code>bool([])</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>список</td>
<td><code>bool([5, 'a'])</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>словарь *</td>
<td><code>bool({})</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>словарь</td>
<td><code>bool({1:'s'})</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>множество *</td>
<td><code>bool(set())</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>множество</td>
<td><code>bool(set([5,a]))</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>None</code></td>
<td><code>bool(None)</code></td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<p>* &mdash; данные коллекции будут рассмотрены позже. </p>
<h2 id="_10">Интерпретация логических значений как чисел</h2>
<p><a name="bool_as_number"></a>
Логические значения в языке Python могут интерпретироваться как числа: <code>True</code> как 1, <code>False</code> как 0.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; True + True
2
&gt;&gt;&gt; True + False
1
&gt;&gt;&gt; False + False
0
&gt;&gt;&gt; s = [10, 20]
&gt;&gt;&gt; s[False]
10
&gt;&gt;&gt; s[True]
20</code></pre>
<p>Здесь упоминается индексная адресация списков, которая будет рассмотрена <a href="#index_addressing">здесь</a> </p>
<hr />
<p><a name="index_entry_i_13"></a></p>
<h1 id="_11">Переменные</h1>
<p>Понятие <strong>переменной</strong> нам известно из математики, где переменная есть символ замещающий некоторое 
значение или представляющий некоторый набор или множество значений, которые называются <em>областью
определения</em>. </p>
<p>В языках программирования переменная также является символом, который некоторым образом представляет
некоторое значение. В ряде случаев допускаются так называемые неопределенные значения, которые по
сути являются лишь одним из вариантов некоторого определенного значения, которое договорились 
считать неопределенным.</p>
<p>Аналогом математической области определения в языках программирования можно считать тип значения или
тип данных. Например, если тип данных строка, то значением может быть только строка.</p>
<p>Отличительной (хотя и не уникальной) чертой языка Python, является способность одной и той же 
переменной представлять значения различных типов. (Понятно, что в конкретный момент времени это 
значение будет одно, следовательно и тип будет один.) т.е., в принципе, можно считать что 
переменные в языке Python сами по себе не имеют типов.</p>
<p>Рассмотрим понятие переменной с точки зрения архитектуры вычислительного устройства, безотносительно
языка программирования. На уровне машинного кода понятия переменной не существует. Аналогичный 
функционал может быть реализован с использованием некоторой области памяти (назовем ее <em>ссылкой</em>), 
в которой находится не само значение, а адрес этого значения, где-то в другом месте памяти. </p>
<p>В языке Python, так же принято рассматривать переменные как ссылки. На самом деле в официальной 
документации они называются не переменными, а именами. </p>
<h2 id="_12">Имена переменных</h2>
<p>Переменная имеет имя и указывается с использованием этого имени, например: 
<code>a</code>, <code>d</code>, <code>x1</code> или более описательные: <code>age</code>, <code>name</code>, <code>total_amount</code>.</p>
<p>Правила для имен переменных Python:</p>
<ul>
<li>Имя переменной должно начинаться с буквы или символа подчеркивания.</li>
<li>Имя переменной не может начинаться с цифры.</li>
<li>Имя переменной может содержать только буквенно-цифровые символы и символы подчеркивания 
    (<code>A</code>-<code>z</code>, <code>0</code>-<code>9</code> и <code>_</code>).</li>
<li>Имена переменных чувствительны к регистру (<code>age</code>, <code>Age</code> и <code>AGE</code> — это три разные переменные).</li>
<li>Имена, начинающиеся с символа подчеркивания, принято использовать для так называемых "внутренних"
    переменных, т.е. переменных которые не следует использовать вне контекста (например, модуля),
    в котором они определены. Технически язык Python не препятствует использованию таких переменных
    вне контекста. Однако согласно договоренности, такая переменная может быть впоследствии 
    переопределена.</li>
<li>Имена, начинающиеся с двух символов подчеркивания, предназначены для элементов стандартных 
    библиотек Python, и программистам их вообще не следует использовать для своих переменных.</li>
</ul>
<pre class="highlight"><code class="language-shell">myvar = "John"
my_var = "John"
_my_var = "John"
myVar = "John"
MYVAR = "John"
myvar2 = "John"</code></pre>
<h2 id="_13">Использование переменных</h2>
<p>Переменная, представляющая значение, может быть использована тем же способом что и значение. </p>
<hr />
<p><a name="index_entry_i_14"></a></p>
<h1 id="_14">Операции</h1>
<p><strong>Операции</strong> нужны для выполнения <em>действий</em> над значениями. Среди всего множества операций языка
Python можно выделить следующие: </p>
<ul>
<li>арифметические:<ul>
<li>простые <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>;</li>
<li>более сложные: <code>//</code> &mdash; деление нацело, <code>%</code> &mdash; остаток от деления.</li>
</ul>
</li>
<li>конкатенация (соединение) строк, например: <code>"А" + "В"</code> даст в результате <code>"AB"</code>; </li>
<li>повторение строк, например: <code>'a' * 5</code> даст <code>'aaaaa'</code>;</li>
<li>сравнение: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, 
    например: <code>1 &gt;= 2</code> даст <code>False</code>, <code>"А" == 'A'</code>даст <code>True</code>. </li>
<li>
<p>логические: <code>and</code>, <code>or</code>, <code>not</code>, например:</p>
<table>
<thead>
<tr>
<th>Выражение</th>
<th align="center">Вернет значение</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>True and True</code></td>
<td align="center"><code>True</code></td>
</tr>
<tr>
<td><code>True and False</code></td>
<td align="center"><code>False</code></td>
</tr>
<tr>
<td><code>False or True</code></td>
<td align="center"><code>True</code></td>
</tr>
<tr>
<td><code>not False</code></td>
<td align="center"><code>True</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a name="index_entry_i_15"></a>операция присвоения &mdash; присваивает (назначает) значение переменной. 
    Например, после выполнения 
    операции <code>x = 5</code> использование x будет приравнено к использованию числа 5.</p>
</li>
<li>комбинированные операции: <code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code> b т.д.
    Например: операция <code>X += 3</code> увеличит значение <code>X</code> на 3. Очевидно с левой стороны операции может
    быть только переменная.</li>
<li>функция <code>len()</code> &mdash; размер коллекции или строки, например:
    len('abc')` вернет значение 3. Понятие функции будет рассмотрено ниже.</li>
</ul>
<p><a name="index_entry_i_16"></a></p>
<h2 id="_15">Цепочка сравнений</h2>
<p>Сравнения могут быть связаны произвольно и записаны в <strong>цепочки сравнений</strong>, в которых для 
соединения сравнений используются неявные логические операторы <code>and</code>.</p>
<p><code>x &lt; y &lt;= z</code> эквивалентно  <code>x &lt; y</code> and <code>y &lt;= z</code></p>
<p>В примере выше <code>y</code> вычисляется только один раз. Если <code>x &lt; y</code> оказывается ложным, то в обоих случаях, 
приведенных выше <code>z</code> не оценивается вообще.</p>
<p>Еще пример:</p>
<p><code>a &lt; b &lt;= c &lt; d</code> эквивалентно <code>a &lt; b</code> and <code>b &lt;= c</code> and <code>c &lt; d</code></p>
<p>Рассматривая это выражение как последовательность операций, то независимо от приоритетов операции
<code>==</code> и <code>in</code> получаем:</p>
<ul>
<li><code>(False == False) in [False]</code> &mdash; дает <code>False</code></li>
<li><code>False == (False in [False])</code> &mdash; дает <code>False</code></li>
</ul>
<p>Поскольку это цепочка сравнения, то данное выражение <code>False == False in [False]</code> эквивалентно 
(False == False) and <code>(False in [False])</code>, которое возвращает <code>True</code>.</p>
<p>Более подробно об этих и других операциях можно посмотреть 
<a href="https://www.w3schools.com/python/python_operators.asp">здесь</a>. </p>
<p><a name="index_entry_i_17"></a></p>
<h2 id="_16">"Моржовый" оператор</h2>
<p>Неплохое объяснение можно найти <a href="https://medium.com/nuances-of-programming/%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%B8-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B2-python-d2e70bf85a40">здесь</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Данный оператор появился в версии Python 3.8. Интерпретаторы более ранних версий будут считать 
использование этого оператора ошибкой.</p>
</div>
<p><strong>"Моржовый" оператор</strong> <code>:=</code> (<em>англ.</em> walrus operator) выполняет присвоение переменной значения внутри
выражения. Например:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; 1 + (a := 5) * a
26</code></pre>
<p>Здесь выражение <code>a := 5</code> определяет переменную <code>a</code> и присваивает ей значение 5. Сам оператор <code>:=</code>
возвращает присвоенное значение, в данном случае 5. Определенная переменная может быть использована
далее в выражении. </p>
<p>Другой пример: вывести введенное с клавиатуры число, его квадрат и куб.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; print(n := int(input()), n ** 2, n ** 3)
3
3 9 27</code></pre>
<p>Без оператора <code>:=</code> потребовалось бы вводить число в отдельной строке.</p>
<hr />
<p><a name="index_entry_i_18"></a></p>
<h1 id="_17">Выражения</h1>
<p><strong>Выражение</strong> &mdash; это конструкция состоящая из:</p>
<ul>
<li>значений;</li>
<li>переменных;</li>
<li>вызова функций (о них позже); </li>
<li>других выражений;</li>
<li>операций, которые служат для соединения других элементов. </li>
</ul>
<p>Пример выражения: <code>20 + Х - len(a)</code>.</p>
<p>Выражение в программе вычисляется и формируется <strong>значение</strong>, которое может быть присвоено переменной
либо участвовать в вычислении других выражений. Указатель значения либо переменной, так же является 
выражением. Например: <code>5</code>, <code>Х</code>, <code>"Х"</code>. </p>
<p><a name="index_entry_i_19"></a>
Значение которое заданно непосредственно без вычислений называется <strong>литералом</strong>. Например: <code>"аbc"</code>, 
<code>25.3</code>.</p>
<p>Выражение можно представить как иерархическую структуру, в которой одни элементы (выражения) 
включают другие. Рассмотрим пример: </p>
<pre class="highlight"><code class="language-code">max(2 + 2, len([0, 0] * 3))</code></pre>
<p><img src="../pict/expression.png" class="floatRight" /></p>

<p>На самом верхнем уровне выражение является вызовом функции <code>max</code> с двумя аргументами. Функция 
принимает аргументы в виде значений, следовательно, выражения, заданные в качестве аргументов,
должны быть предварительно вычислены. </p>
<p>Первый аргумент представляет собой операцию сложения двух значений, заданных литералами. Результатом
этой операции будет 4.</p>
<p>Второй аргумент предоставляет собой вызов функции <code>len</code> с аргументом, заданным выражением, 
которое, в свою очередь, представляет собой умножение списка (заданного литералом) на число (тоже
заданное литералом). Элементы списка так же заданны литералами. Результатом умножения будет список 
из шести нулей. Следовательно, функция <code>len</code> вернет 6.</p>
<p>В конечном счете функция <code>max</code> будет вызвана с аргументами 4 и 6 и вернет 6.</p>
<p style="clear: both;"></p>

<hr />
<h1 id="_18">Ветвление</h1>
<p><a name="index_entry_i_20"></a> 
<strong>Ветвление</strong> &mdash; это управляющая конструкция, которая позволяет выбрать последовательность операции в 
некоторой точке программы. Без управляющих конструкций операции выполняются в том порядке, в котором
они  представлены в программе. Последующие операции выбираются по <em>условию</em>, которое являются 
логическим  выражением. </p>
<pre class="highlight"><code class="language-code">t = 38
if t &lt; 37:  # оператор условия *if* со значением *t &lt; 37*
    print('здоров')  #  тело условия
else: # "альтернативная ветка" 
    print('болен')   </code></pre>
<p>Программа напечатает "болен".</p>
<hr />
<p><a name="index_entry_i_21"></a> </p>
<h1 id="_19">Циклы</h1>
<p><strong>Цикл</strong> &mdash; это управляющая конструкция, которая позволяет выполнять последовательность операций 
несколько раз. Два вида циклов: цикл по условию <code>while</code> и цикл по счетчику <code>for</code>. </p>
<p><a name="index_entry_i_22"></a> </p>
<h2 id="_20">Цикл по условию</h2>
<p>Тело цикла выполняется до тех пор, пока условие верно. </p>
<pre class="highlight"><code class="language-code">i = 3
while i &gt; 0:
    print(i)
    i = i - 1</code></pre>
<p>Программа выведет : 1, 2, 3.</p>
<p><a name="for_loop"></a><a name="index_entry_i_23"></a></p>
<h2 id="_21">Цикл по счетчику</h2>
<p>Цикл по счетчику выполняется по элементам итерируемого объекта. Итерируемым 
объектом может быть массив, из него можно последовательно получать (читать) элементы.</p>
<pre class="highlight"><code class="language-code">a = [1, 2, 3]
for x in a:
    print(x)</code></pre>
<p>Цикл <code>for</code> последовательно выбирает элементы списка <code>а</code> и присваивает их переменной <code>х</code>, которую 
можно использовать в теле цикла. Этот цикл можно назвать <em>синтаксический сахар</em>, потому что все тоже
самое можно сделать с помощью цикла <code>while</code>. </p>
<p>Список является <a href="#iterable_objects">итерируемым объектом</a>, поэтому его можно использовать в 
операторе <code>for</code>.</p>
<p><a name="index_entry_i_24"></a>
Другим  вариантом итерируемого объекта является <em>последовательность</em>. В математике ее могут называть
<em>прогрессией</em>. Функция <code>range()</code> является <em>генератором</em>, представляет арифметическую прогрессию и 
принимает аргументы:</p>
<ol>
<li>начальное значение (включительно);</li>
<li>конечное значение (не включительно);</li>
<li>приращение (шаг), по умолчанию +1.</li>
</ol>
<p>Если указать один аргумент, то последовательность будет от 0 до указанного числа с шагом +1.</p>
<pre class="highlight"><code class="language-code">for i in range(2, 8, 2):
    print(i)</code></pre>
<p>Данная программа напечатает 2, 4, 6.</p>
<pre class="highlight"><code class="language-code">for i in range(3):
    print(i)</code></pre>
<p>Данная программа напечатает 0, 1, 2.</p>
<p><a name="index_entry_i_25"></a></p>
<h2 id="else">Блок <code>else</code></h2>
<p>Также в циклах <code>while</code> и <code>for</code> можно указать <code>else</code>-блок после основного блока цикла. <code>else</code>-блок в 
циклах выполняется один раз после завершения работы цикла, но только в случае, если цикл не был прерван 
инструкцией <code>break</code>.</p>
<pre class="highlight"><code class="language-code">    n=input("Введите целое число, больше 1 ") # 1 Считали число n
     for d in range(2, n):                     # 2 d меняется от 2 до n-1
         if n % d == 0:                        # 3 Проверка: n делится на d?
             print n, "имеет делитель", d      # 4
             break                             # 5 Завершаем цикл for
     else:                                     # 6 Это else-блок цикла
         print n, "простое число"              # 7</code></pre>
<p><a name="index_entry_i_26"></a></p>
<h2 id="c">Циклы c предусловием и постусловием</h2>
<p>Циклы <code>for</code> и <code>while</code> являются циклами с предусловием, т.е. условие проверяется перед началом 
итерации и возможно такая ситуация, когда тело цикла не выполняется ни разу. 
(В случае с циклом <code>for</code> это происходит, если итерируемый объект пустой.) В цикле с постусловием 
условие проверяется по 
окончанию итерации и поэтому как минимум одна итерация будет выполнена. В языке Python нет специального
синтаксиса для циклов с постусловием. Однако они могут быть реализованы следующим образом.
Например есть задача: получать числа с клавиатуры и считать сумму положительных чисел, при вводе 
отрицательного  числа прекратить выполнение программы.</p>
<pre class="highlight"><code class="language-code">sum = 0
while True:
    a = int(input())
    if a &lt; 0:
        break
    sum += a
print(sum)</code></pre>
<p>Здесь постусловие относится к вводу числа с клавиатуры. Мы не знаем, что будет введено поэтому нам
нужно начать выполнение тела цикла в любом случае. Дальше принимается решение переходить или нет 
на следующую итерацию.</p>
<p>В цикле <em>for</em> указывается переменная и множество значений, по которому будет пробегать переменная.
Множество значений может быть задано <em>списком, кортежем, строкой или диапазоном</em>.
В списке значений могут быть выражения различных типов, например:</p>
<pre class="highlight"><code class="language-shell">for i in 1, 2, 3, 'one', 'two', 'three':
    print(i)</code></pre>
<hr />
<p><a name="index_entry_i_27"></a><a name="iterable_objects"></a></p>
<h1 id="_22">Итерируемые объекты</h1>
<p><strong>Итерируемые объекты</strong> &mdash; объекты позволяющие получать последовательность значений. К таким 
объектам относятся: </p>
<ul>
<li>списки;</li>
<li>словари;</li>
<li>множества;</li>
<li>кортежи;</li>
<li>строки, которые по факту являются списками символов;</li>
<li>генераторы.</li>
</ul>
<p><a href="program_design.html#iterable_objects">Итерируемые объекты</a> можно использовать в цикле <code>for</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i in {'a', 'b', 'c'}:
...     print(i)
...
a
c
b</code></pre>
<p><a name="index_entry_i_28"></a>
Функция <code>zip()</code> является интересным примером. Она принимает итерируемые объекты и возвращает
генеротор (который также являются итерируемым объектом). Пример:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i, j in zip(range(1, 4), ['яблоки', 'груши', 'сливы']):
...     print(i, j)
...
1 яблоки
2 груши
3 сливы</code></pre>
<p>В данном примере функция <code>zip()</code> принимает два итерируемых объекта, генератор и список, и 
возвращает последовательность пар элементов (кортеж). В цикле <code>for</code> данные значения присваиваются
переменным цикла <code>i</code> и <code>j</code>.</p>
<hr />
<h1 id="_23">Функция</h1>
<p><a name="index_entry_i_29"></a><a name="function"></a>
<strong>Функция</strong> в python - это объект, принимающий <em>аргументы</em> и возвращающий <em>значение</em>.
Функция обеспечивает <strong>инкапсуляцию</strong> программного кода, т.е. предоставляет единую точку входа
и избавляет пользователя функции от необходимости знать особенности ее реализации.
Обычно функция определяется с помощью инструкции <code>def</code>. Инструкция <code>return</code> говорит, что нужно 
вернуть значение. Чтобы вызвать функцию, используйте имя функции, за которым следуют круглые скобки. 
Термины <em>параметр</em> и <em>аргумент</em>  могут считаться синонимами обозначающими значения, которые
передаются в функцию.</p>
<pre class="highlight"><code class="language-shell">def bubble_sort(a):</code></pre>
<p>По умолчанию функция должна вызываться с правильным количеством аргументов. Это означает, что если 
ваша функция ожидает 2 аргумента, вы должны вызывать функцию с 2 аргументами, не больше и не меньше.
Если вы не знаете, сколько аргументов будет передано в вашу функцию, добавьте <code>*</code>перед именем 
параметра в определении функции. Аргументы приходят извне и внутри функции могут использоваться так 
же, как и локальные (внутри функции) переменные. Аргументы, которые передаются в функцию через 
запятую, называются <em>позиционными</em>. Существуют и <em>именнованные</em> параметры, которые имеют имена.
Например: 
<pre class="highlight"><code class="language-code">print (1, 'a', True, sep=',', end= '|')</code></pre></p>
<p>В данном примере в функцию <code>print</code> передаются три позиционных аргумента (<code>1</code>, <code>'a'</code>, <code>True</code>) и два
именнованных аргумента (<code>sep=','</code>, <code>end= '|'</code>), они указываются всегда после позиционных.</p>
<p><a name="index_entry_i_30"></a><a name="functions_first_class_objects"></a>
Особенности функций как объектов первого класса:</p>
<ul>
<li>Функции можно присваивать переменным.</li>
<li>Функция может быть примером объекта.</li>
<li>Функцию можно вернуть из функции.</li>
<li>У функций те же свойства и методы, что и у объектов.</li>
<li>Функцию можно передать в качестве аргумента при вызове другой функции.</li>
</ul>
<pre class="highlight"><code class="language-code">def print_field(string, transform):
    print('[' + transform(string) + ']')

def simple_transform(string):
    return string   # Что пришло, то функция и вернула

def password_transform(string):
    return '*' * len(string)  # Возвращает звездочки

print_field("I love my cat", simple_transform)
print_field("my secret", password_transform)</code></pre>
<p>Объяснение. Функция <code>print_field</code> принимает в качестве второго аргумента функцию, которую вызывает
внутри своего тела. При вызове функции <code>print_field</code> ей могут быть переданы различные функции с 
различным поведением. В данном примере будет выведено:</p>
<pre class="highlight"><code class="language-shell">[I love my cat]
[*********]</code></pre>
<p>Другой пример использования функции как объекта можно посмотреть
<a href="problems/4_python_drill.html#password_strength">здесь</a>.</p>
<p><a name="index_entry_i_31"></a><a name="lambda"></a>
В функцию <code>print_field</code> можно передавать анонимную функцию используя lambda-выражение. </p>
<pre class="highlight"><code class="language-code">print_field("I love my cat", lambda s: s)
print_field("my secret", lambda s: '*' * len(s))</code></pre>
<p>В данном случае lambda-выражение позволяет нам определить функцию на месте, т.е. в той точке кода, 
где требуется ее указать. По сравнению с предыдущим вариантом, дополнительных функций 
(<code>simple_transform</code> и <code>password_transform</code>) создавать не нужно. Результат выполнения будет такой 
же точно.</p>
<p>Другой пример использования lambda-выражений смотри
<a href="problems/3_final_tasks.html#coordinates_1">здесь</a>.</p>
<p><a name="index_entry_i_32"></a>
Функция может возвращать результат. Для этого в функции используется оператор <code>return</code>, после 
которого указывается возвращаемое значение:</p>
<pre class="highlight"><code class="language-code">1. def get_message():
1.   return "Hello METANIT.COM  # return возвращаемое значение.

message = get_message()  # получаем результат функции get_message в переменную message
print(message)          # Hello METANIT.COM

# можно напрямую передать результат функции get_message
print(get_message())    # Hello METANIT.COM</code></pre>
<p>Оператор return не только возвращает значение, но и производит выход из функции. Поэтому он должен 
определяться после остальных инструкций.</p>
<p><a name="index_entry_i_33"></a>
<strong><code>yield</code></strong> — это ключевое слово в Python, которое используется для возврата из функции с сохранением 
состояния ее локальных переменных, и при повторном вызове такой функции выполнение продолжается с 
оператора yield, на котором ее работа была прервана. Любая функция, содержащая ключевое слово yield,
называется генератором. Можно сказать, yield — это то, что делает ее генератором.</p>
<p><pre class="highlight"><code class="language-code">def fibonacci(n):
    """функция-генератор возвращает последовательность Фибоначчи""" 
    f1 = -1
    f2 = 1
    for i in my_range(0, n, 1):
        f3 = f1 + f2 
        yield f3 
        f1 = f2
        f2 = f3</code></pre>
Преимущества <code>yield</code>:</p>
<p>Поскольку генераторы автоматически сохраняют и управляют состояниями своих локальных переменных, 
программист не должен заботиться о накладных расходах, связанных с выделением и освобождением памяти.
Так как при очередном вызове генератор возобновляет свою работу, а не начинает с самого начала, общее 
время выполнения сокращается.</p>
<p>Недостатки <code>yield</code>:</p>
<p>Иногда использование <code>yield</code> может вызвать ошибки, особенно если вызов функции не обрабатывается 
должным образом.
За оптимизацию времени работы и используемой памяти приходится платить сложностью кода, поэтому иногда
трудно сходу понять логику, лежащую в его основе.  </p>
<p><a name="index_entry_i_34"></a> 
Функция <code>input()</code> в Python временно приостанавливает выполнение программы и ожидает, пока 
пользователь введёт данные. Как только функция получает данные от пользователя, Python автоматически
заносит их в переменную, чтобы с ними было удобно работать.
Функция input() получает только один аргумент и это текст подсказки, который выводится на экран,
чтобы пользователь понимал что от него требуется. </p>
<pre class="highlight"><code class="language-code">X = int(input())
Y = int(input())
print(X*60 + Y)
5
20
320</code></pre>
<p>Функция <code>input()</code> всегда возвращает строковое значение, даже числа возвращаются в виде строковых 
символов. Функция <code>int()</code> принимает текстовое представление целого числа и возвращает 
соответствующее число. Например: </p>
<pre class="highlight"><code class="language-code">&gt;&gt;&gt; print(int('0017'))
17</code></pre>
<p><a name="index_entry_i_35"></a>
Функция <code>sqrt()</code> – это встроенная функция, которая возвращает квадратный корень из любого числа.</p>
<pre class="highlight"><code class="language-code">a = int(input())
b = int(input()) 
c = int(input())
p = ((a + b + c) / 2)
s = (p * (p-a) * (p-b) * (p-c)) ** (1/2)
print(s)</code></pre>
<hr />
<p><a name="variable_argument_functions"></a></p>
<h2 id="_24">Функции с переменным количеством аргументов</h2>
<p>В языке Python функции могут иметь фиксированное количество аргументов. Например, функция <code>input()</code>
принимает <code>0</code> или <code>1</code> аргумент: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; print(input('23',' hjk'))
TypeError: input expected at most 1 argument, got 2 (функция не может принимать больше 1 аргумента)</code></pre>
<p>Однако есть функции, которые могут принимать различное количество аргументов, например функция
<code>print()</code> печатает переданное количество аргументов с заданным разделителем. Рассмотрим пример 
написания подобной функции. </p>
<pre class="highlight"><code class="language-code">def minimum(*args):
    if len(args) &lt; 1:
        return None
    min_valiu = args[0]
    for v in args:
        if v &lt; min_valiu:
            min_valiu = v
    return min_valiu

print(minimum()) 
print(minimum(42)) 
print(minimum('b', 'a')) 
print(minimum(2, 3, 5, 0, 1)) </code></pre>
<pre class="highlight"><code class="language-shell">&gt;python delete.py
None
42
a
0</code></pre>
<p>Функция <code>minimum</code> может принимать разное количество аргументов, в том числе ноль. В списке 
аргументов такой функции следует указать <code>*</code> перед именем аргумента. При этом при вызове функции
все переданные ей аргументы представляются как единое значение типа список. </p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Точно такой же синтаксис используется при вызове функции, однако тогда он имеет <strong>совсем 
другое значение</strong> (см. <a href="#spread_operator">здесь</a>).</p>
</div>
<hr />
<p><a name="index_entry_i_36"></a><a name="spread_operator"></a></p>
<h2 id="_25">Распаковка коллекций в аргументы при вызове функции</h2>
<p>Бывают ситуации, когда есть функция принимающая определенное количество аргументов, и есть
коллекция, содержащая соответствующее количество элементов. Например, функция <code>range()</code> может 
принимать три аргумента и, предположим, есть такая коллекция: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [1, 6, 2]</code></pre>
<p>Вызвать функцию <code>range()</code> с аргументами из этого списка можно так: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i in range(a[0], a[1], a[2]):
...     print(i)
...
1
3
5</code></pre>
<p>В языке Python есть более короткий способ с использованием так называемой <strong>распаковки коллекций</strong>
(<em>англ.</em> spread operator), которая преобразует коллекцию в отдельные аргументы при вызове функции.
Применяется путем добавления <code>*</code> перед указанием коллекции:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i in range(*a):
...     print(i)
...
1
3
5</code></pre>
<p>Как можно видеть, результат тот же самый! </p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Данное использование символа <code>*</code> отличается от его использования при определении функции
(см. <a href="#variable_argument_functions">здесь</a>). В данном случае мы функцию не определяем,
а <strong>вызываем</strong>.</p>
</div>
<p>Вот еще один пример использования:</p>
<pre class="highlight"><code class="language-code">a = sorted([int(input()) for _ in range(3)], reverse=True)
print(*a, sep="\n") </code></pre>
<p>На вход программе подается три целых числа, каждое на отдельной строке.
Программа должна вывести три числа, каждое на отдельной строке, упорядоченных от большего к меньшему.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>На самом деле использование распаковки здесь необязательно. Функция <code>min</code> может принимать
 итерируемый объект в качестве единственного аргумента.</p>
</div>
<hr />
<h1 id="_26">Коллекции</h1>
<p><strong>Коллекции</strong> &mdash; это комплексные значения, которые содержат изначально неопределенное количество
других значений. Далее рассмотрим конкретные типы коллекций.</p>
<p><a name="index_entry_i_37"></a> </p>
<h2 id="_27">Массив</h2>
<p><strong>Массив</strong> &mdash; это сложное (композитное) значение, состоящее из идущих подряд значений, 
которые называются <em>элементами массива</em>.</p>
<pre class="highlight"><code class="language-code">x = 10
a = [1, 'hi', 1 + 1, x] # В данном примере массив *а* содержит элементы: [`1`, `hi`, `2`, `10`]
</code></pre>
<p><a name="index_entry_i_38"></a><a name="index_addressing"></a>
Элементы массива имеют порядковые номера, которые называются 
<em>индексами</em>. Индексы &mdash; это последовательные целые числа начинающиеся с нуля. Доступ к элементу
массива осуществляется по индексу следующим образом: выражение  <code>a[0]</code> вернет выражение <code>1</code>; после 
<code>операции</code> <code>a[2] = 2</code>, третий по порядку элемент массива будет являться 2.
Для массивов определена функция <code>len</code>, которая возвращает длину массива. Выражение <code>len(а)</code>вернет 
значение 4.</p>
<p>Массивы используют для предоставления набора значений количество которых заранее не известно. 
Рассмотренная структура в языке Python является не массивом, а списком, который в свою очередь 
является объектом (см. <a href="#objects_and_classes">ниже</a>). Данный объект обладает методами для манипуляции 
элементами массива (или, точнее, списка) такими как, добавление, удаление, сортировка. </p>
<h3 id="_28">Вложенные списки или матрицы</h3>
<p><a name="index_entry_i_39"></a>
Вложенные списки &mdash; это когда в качестве элемента одного списка, являются другие списки. Если все 
вложенные списки имеют одинаковую длину, то такой список может представлять прямоугольную таблицу 
или <em>матрицу</em>.</p>
<p>В языке программирования Питон таблицу можно представить в 
виде списка строк, каждый элемент которого является в свою очередь списком, например, чисел. 
Например, создать числовую таблицу из трёх строк и трех столбцов можно так:</p>
<div class="tableHederless"></div>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">-6</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">-1</td>
<td align="center">4</td>
<td align="center">9</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; m = [[5, 2, 7], [3, -6, 8], [-1, 4, 9]]
&gt;&gt;&gt; m
[[5, 2, 7], [3, -6, 8], [-1, 4, 9]]</code></pre>
<p>Мы можем обратиться к любому элементу из этой матрицы по индексам <code>m[i][j]</code>.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; m[0]
[5, 2, 7]
&gt;&gt;&gt; m[0][0]
5
&gt;&gt;&gt; m[1]
[3, -6, 8]
&gt;&gt;&gt; m[2][1]
4</code></pre>
<p><a name="list_memory_model"></a></p>
<h3 id="_29">Ссылочная модель вложенных списков</h3>
<p>Пусть имеем вложенный список созданный следующим образом:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [[0] * 3]</code></pre>
<p>В памяти это будет выглядеть следующим образом (поз. 1):</p>
<p><img alt="" src="../pict/list_memory_model.png" /></p>
<p>Если мы хотим иметь три вложенных списка, то мы можем поступить следующим образом: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [[0] * 3] * 3</code></pre>
<p>При этом память будет выглядеть как на рисунке, поз. 2, т.е. элементы внешнего списка будут 
ссылаться на один и тот же список. При этом возможна следующая ситуация:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a[0][0] = 1
&gt;&gt;&gt; a
[[1, 0, 0], [1, 0, 0], [1, 0, 0]]</code></pre>
<p>Здесь был изменен первый вложенный список, но поскольку все вложенные списки это один и тот же 
список, то в результате список будет выглядеть так, как это видно из кода.</p>
<p><a name="index_entry_i_40"></a>
Чтобы создать действительно разные списки (как на рисунке в поз. 3) можно использовать средство 
генерации списков (<em>list comprehension</em>):</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [[0] * 3 for i in range(3)]
&gt;&gt;&gt; a[0][0] = 1
&gt;&gt;&gt; a
[[1, 0, 0], [0, 0, 0], [0, 0, 0]]</code></pre>
<h2 id="_30">Кортеж</h2>
<p><a name="index_entry_i_41"></a>
<strong>Кортежи</strong> можно представить как неизменяемые массивы. Кортеж задается перечислением значений через 
запятую, при необходимости данные перечисления можно взять в скобки. Помимо прочего они позволяют 
<em>множественные присваивания</em>. Присваивание значений сразу нескольким переменным.  </p>
<pre class="highlight"><code class="language-code">def get_tuple():
    return 5, "с", True  # возвращает кортеж из трех элементов разного типа.
    # функция заканчивает свою работу.

А, В, С = get_tuple()
print(А, В, С)</code></pre>
<h2 id="_31">Словарь</h2>
<p><a name="index_entry_i_42"></a>
<strong>Словарь</strong> можно представить как набор <em>ключей</em> и соответствующих им значений. Например:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d={'dog': 'собака', 'cat': 'кот', 'human': 'человек'}
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кот', 'human': 'человек'}</code></pre>
<p>В этом примере мы создали словарь <code>d</code> с тремя элементами. Рассмотрим основные операции со словарями.</p>
<h3 id="_32">Поиск по ключу</h3>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d['cat']
'кот'
&gt;&gt;&gt; d['cow']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'cow'</code></pre>
<p>Поиск по ключу 'cat' вернул соответствующее значение, а поиск по ключу 'cow' вызвал ошибку, потому
что элемента с таким ключом в словаре нет. Возможен другой способ поиска, при котором для 
отсутствующего ключа возвращается пустое значение:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; print(d.get('cow'))
None</code></pre>
<h3 id="_33">Удаление элемента</h3>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; del d['human']
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кот'}</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Если удаляемый ключ отсутствует, то операция удаления вызовет ошибку <code>KeyError</code> как в 
предыдущем примере.</p>
</div>
<h3 id="_34">Добавление элемента</h3>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d['cow'] = 'корова'
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кошка', 'cow': 'корова'}</code></pre>
<h3 id="_35">Изменение элемента</h3>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d['cat'] = 'кошка'
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кошка', 'cow': 'корова'}</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Следует обратить внимание на то, что синтаксис при изменении и добавлении элемента совпадает.
Если ключ уже существует, то соответствующее значение меняется, в противном случае добавляется 
новый элемент с заданным ключом.</p>
</div>
<p><a name="index_entry_i_43"></a>    </p>
<h3 id="_36">Итерация по словарю</h3>
<p>Имеется словарь <code>d</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кошка', 'cow': 'корова'}</code></pre>
<p>Требуется выполнить с каждым элементом некоторые действия. Для простоты будем печатать ключи и 
значения. Существует три способа итерации.</p>
<p>Также см. <a href="#for_loop">цикл <code>for</code></a>.</p>
<p><strong>По ключам</strong> </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for k in d.keys():
...     print(k)
...
dog
cat
cow</code></pre>
<pre class="highlight"><code>key = input().split()
new_data = {i:user[i] for i in key}
print(new_data)</code></pre>
<p>Метод <code>d.keys()</code> возвращает список ключей словаря <code>d</code> как итерируемый объект. Следовательно, этот
объект может быть использован в цикле <code>for</code>. На каждой итерации переменная цикла <code>k</code> получает 
значение очередного ключа.</p>
<p>Идентичным образом работает выражение <code>for k in d:</code>.</p>
<p><strong>По значениям</strong></p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for v in d.values():
...     print(v)
...
собака
кошка
корова</code></pre>
<p><strong>По парам ключ-значение</strong></p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for k, v in d.items():
...     print(k, v)
...
dog собака
cat кошка
cow корова </code></pre>
<p>Метод <code>d.items()</code> возвращает список кортежей из двух элементов, ключа и значения. Поэтому 
используются две переменные цикла, <code>k</code> и <code>v</code>.</p>
<h3 id="_37">Методы словаря</h3>
<p><a name="index_entry_i_44"></a>
<strong><code>setdefault()</code></strong> &mdash; добавляет пару ключ-значение только в том случае, если такого ключа нет.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d = {"a": 1, "b": 2}
&gt;&gt;&gt; d.setdefault("a", 10)
1
&gt;&gt;&gt; d
{'a': 1, 'b': 2}
&gt;&gt;&gt; d.setdefault("c", 3)
3
&gt;&gt;&gt; d
{'a': 1, 'b': 2, 'c': 3}</code></pre>
<p><strong><code>pop()</code></strong> &mdash;  возвращает значение, находящееся под указанным ключом, а из самого словаря 
удаляется пара с данным ключом. Вызов метода без указания ключа, либо же без существующего ключа, 
приводит к ошибке <code>TypeError</code>.</p>
<p><strong><code>popitem()</code></strong> &mdash; удалит и вернет двойной кортеж (key, value) из словаря. Пары возвращаются с 
конца словаря, в порядке LIFO (последним пришёл - первым ушёл). При попытке удаления элементов из 
пустого словаря возникает ошибка <code>KeyError</code>.</p>
<p><a name="index_entry_i_45"></a></p>
<h2 id="_38">Множества</h2>
<p><strong>Множества</strong> в математике представляют набор элементов и предполагают такие операции как: 
объединение, пересечение, вычитание. Более подробно см. в 
<a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE">Википедии</a>.</p>
<p>В языке Python множество (объект типа <code>set</code>) представляет набор уникальных значений: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; s = {1, 2, 2, 3, 198}
&gt;&gt;&gt; s
{1, 2, 3, 198}</code></pre>
<p>Как видно из примера, конструктор непустого множества отличается от конструктора словаря тем, что
в нем перечисляются только значения без ключей. Конструктор пустого множества &mdash; <code>set()</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; s = set()
&gt;&gt;&gt; s.add(50)
&gt;&gt;&gt; s.add(10)
&gt;&gt;&gt; s.add(30)
&gt;&gt;&gt; s.add(30)
&gt;&gt;&gt; s
{50, 10, 30}</code></pre>
<p>Здесь показано создание пустого множества и добавление в него элементов. Как видно из примера,
множество обеспечивает <strong>уникальность</strong> добавляемых элементов.</p>
<p>Рассмотрим некоторые другие операции. Определение наличия элемента в множестве:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; 10 in s
True
&gt;&gt;&gt; 20 in s
False</code></pre>
<p>Пересечение (<code>&amp;</code>) множеств:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; {1, 2, 5} &amp; {2, 3, 6, 5}
{2, 5}</code></pre>
<p>Объединение (<code>|</code>) множеств:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; {1, 2, 5} | {2, 3, 6, 5}
{1, 2, 3, 5, 6}</code></pre>
<p>Разность (<code>-</code>) множеств:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; {1, 2, 5} - {2, 3, 6, 5}
{1}</code></pre>
<p><a name="index_entry_i_46"></a><a name="collection_comprehension"></a></p>
<h2 id="_39">Генерация коллекций</h2>
<p>Рассмотрим простой способ генерирования списка, например, квадратов чисел от 1 до 7:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; lst = []
&gt;&gt;&gt; for i in range(1, 8):
...     lst.append(i * i)
...
&gt;&gt;&gt; lst
[1, 4, 9, 16, 25, 36, 49]</code></pre>
<p>Способ рабочий, но достаточно многословный. Конструкция <strong>list comprehension</strong> позволяет сделать 
это в одну строку:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; lst = [i * i for i in range(1, 8)]
&gt;&gt;&gt; lst
[1, 4, 9, 16, 25, 36, 49]</code></pre>
<p>List comprehension работает подобно <a href="#for_loop">циклу <code>for</code></a>, только направляет значения переменной цикла 
в генерируемый список. Подобным способом можно генерировать другие виды коллекций.</p>
<p>Также в этой конструкции возможна фильтрация, например, используя созданный 
список, сгенерируем кортеж, в который  попадут только четные числа, деленные на 2:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; tuple(i // 2 for i in lst if i % 2 == 0)
(2, 8, 18)</code></pre>
<p>Теперь сгенерируем словарь используя тот же самый список, как набор ключей. Значениями будут 
являться двоичные представления этих чисел.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; {i: f"{i:b}" for i in lst}
{1: '1', 4: '100', 9: '1001', 16: '10000', 25: '11001', 36: '100100', 49: '110001'}</code></pre>
<p>Сгенерируем множество из некоторого произвольного списка.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; set(i for i in [2, 2, 1, 1, 3])
{1, 2, 3}</code></pre>
<p>Функция которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а 
чётные нацело делит на два. Можно для решения использовать <em>list comprehension</em>.</p>
<pre class="highlight"><code class="language-code">def modify_list(numbers):
    numbers[:] = [i // 2 for i in numbers if i % 2 == 0]</code></pre>
<h3 id="_40">Генерация коллекций с вложенным циклом</h3>
<p>При генерации коллекций можно использовать вложенные циклы. Рассмотрим на примере декартова 
произведения двух списков:</p>
<pre class="highlight"><code class="language-code">colors = ['White', 'Blue', 'Yellow']
sizes = ['S', 'M']
print([(c, s) for c in colors for s in sizes])</code></pre>
<p>Результат будет такой:</p>
<pre class="highlight"><code class="language-shell">[('White', 'S'), ('White', 'M'), ('Blue', 'S'), ('Blue', 'M'), ('Yellow', 'S'), ('Yellow', 'M')]</code></pre>
<p>Следующая задача обратная предыдущей. Сделать из двумерного списка одномерный.</p>
<pre class="highlight"><code class="language-code">vector = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]
print([num for row in vector for num in row])</code></pre>
<p>Результат будет такой:</p>
<pre class="highlight"><code class="language-shell">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]</code></pre>
<p><a name="index_entry_i_47"></a><a name="anonymous_generator"></a></p>
<h3 id="_41">Анонимный генератор</h3>
<p>Генерация коллекций (list comprehension) создает объект, который занимает какое-то место в памяти.
Потребление памяти составляет О(N).</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; [i*2 for i in range(5)]
[0, 2, 4, 6, 8]</code></pre>
<p>Если в этой конструкции указать круглые скобки вместо квадратных, то получится генератор, 
возвращающий рассчитанные элементы без помещения их в память.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; (i*2 for i in range(5))
&lt;generator object &lt;genexpr&gt; at 0x0000016E82F79BA0&gt;</code></pre>
<p>Полученный объект генератора является итерируемым объектом, который будет возвращать генерируемые 
элементы, не сохраняя их в памяти. </p>
<pre class="highlight"><code class="language-shell">g =(input() for _ in range(2))
&gt;&gt;&gt; g = (i*2 for i in range(5))
&gt;&gt;&gt; sum(g)
20</code></pre>
<p>Точно также можно было бы использовать list comprehension (с квадратными скобками), однако в этом
случае был бы создан список с умноженными на два числами от 0 до 4, который после подсчета суммы 
нам больше не требуется. При использовании генератора (с круглыми скобками) умножение на 2 
происходит "на лету", и полученные элементы нигде не накапливаются. Потребление памяти константно,
О(1).</p>
<p>Можно посчитать сколько цифр в строке.</p>
<pre class="highlight"><code class="language-code">print(sum(i.isdigit() for i in input()))</code></pre>
<p>В этом примере используется <a href="#bool_as_number">интерпретация логических значений как чисел</a>.</p>
<p>Пример использования можно также посмотреть и <a href="problems/4_python_drill.html#ip_address_check">здесь</a>.</p>
<p>Рассмотрим еще один пример. </p>
<p>В случае с list comprehension возвращается список, поэтому все действия (в том числе ввод с 
клавиатуры) выполняются до завершения формирования списка.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [input() for _ in range(2)]
a
b
&gt;&gt;&gt; a
['a', 'b']</code></pre>
<p>Для доказательства отложенной работы генератора рассмотрим следующий пример:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; g =(input() for _ in range(2))
&gt;&gt;&gt; </code></pre>
<p>Здесь мы создали анонимный генератор, который определяет отложенные действия. Как мы видим ввод
с клавиатуры не был запрошен. Это будет сделано во время использования данного генератора.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for s in g: print('--&gt;', s)
...
a
--&gt; a
c
--&gt; c
&gt;&gt;&gt;</code></pre>
<hr />
<h1 id="_42">Модуль</h1>
<p><strong>Модуль</strong> в <em>программировании</em> &mdash; это независимая и функционально законченная часть программы, 
оформленная в виде фрагмента кода и сохраненная в отдельный <em>файл</em>. Чтобы использовать модуль в другой
программе мы его импортируем (import).</p>
<p>Более подробно смотри <a href="python_working_environment.html#library_installation">здесь</a>.</p>
<hr />
<h1 id="_43">Объекты и классы</h1>
<p><a name="index_entry_i_48"></a>   <a name="objects_and_classes"></a>
Простые, "примитивные" типы данных описывают одно значение. Объекты реального мира моделируемые в 
программе могут иметь несколько <em>атрибутов</em> различных типов. Например, книга в каталоге может быть 
описана следующими атрибутами:</p>
<ul>
<li>автор;</li>
<li>название;</li>
<li>год издания;</li>
<li>количество страниц.</li>
</ul>
<p><a name="index_entry_i_49"></a><a name="classes"></a>
<strong>Классы</strong>- это сложные (композитные) типы данных. Класс можно представить как шаблон, на основе 
которого создаются (инстанцируются) <strong>объекты</strong>, которые иногда называются <em>экземплярами</em> класса.
Представьте чертеж дома. В нем содержится вся информация: сколько этажей, какого размера двери, 
окна и т.д. На основе это чертежа мы можем построить дом. Дом — это объект. 
По одному чертежу можно построить несколько домов. Так же и с классом — по нему можно создать 
много объектов. Объект также можно назвать экземпляром класса.
Например, следующий класс представляет сущность "Книга". </p>
<pre class="highlight"><code class="language-code">class Book:
    def __init__(self, author, title, year, page_count):  # функция __init__ это конструктор класса

    # при вызове метода объекта нам обязательно необходимо использовать слово self
    # для обращения к атрибутам объекта внутри класса в его методах также применяется слово self:
        self.author = author  # это одно из полей класса
        self.title = title
        self.year = year
        self.page_count = page_count

    def colofon(self):
        return (self.author + ' "' + self.title + '", ' + str(self.year) + ' г., ' +  
        str(self.page_count) + ' c.')</code></pre>
<p><a name="index_entry_i_50"></a><br />
<strong>Объект</strong> — это набор данных (переменных) и методов (функций), которые с этими данными взаимодействуют.
Объект также можно назвать экземпляром класса, а процесс его создания — инстанцированием.
Пример:</p>
<pre class="highlight"><code class="language-code">book1 = Book('А. Блок', 'Ветер', 1975, 45) # выражение, создающее экземпляр класса Book
print(book1.author)
print(book1.title)
print(book1.colofon()) </code></pre>
<p>Программа выведет строки: "А. Блок", "Ветер".</p>
<hr />
<p><a name="index_entry_i_51"></a><a name="exceptions"></a> </p>
<h1 id="_44">Обработка ошибок</h1>
<p>Ошибки в программировании часто называют <strong>исключениями</strong>, <em>англ</em>.  <strong>exception</strong>.</p>
<p>При возникновении ошибки в программе, Python прекращает выполнение программы и отображает сообщение 
об ошибке. </p>
<pre class="highlight"><code class="language-code">x = 0
print(f 'x = {x}')  # (1)
y = 5 / x           # (2)
print(y)            # (3)</code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
x = 0
Traceback (most recent call last):
  File "hello.py", line 3, in &lt;module&gt;
    y = 5 / x
ZeroDivisionError: division by zero</code></pre>
<p>В нашем примере (строка 1) была выполнена, в (строке 2) произошла ошибка, поэтому остальная часть 
программы (строка 3) не была выполнена. В данном случае сообщение об ошибке было выведено в консоль.</p>
<p>В каких-то случаях такое поведение является логичным, поскольку ошибка является неожиданной и 
дальнейшее выполнение программы будет непредсказуемо. В нашем примере значение переменной <code>y</code> ,
после (строки 2) не определено, поэтому использование ее не возможно. Программист может обработать 
возможную ошибочную ситуацию, например так:</p>
<pre class="highlight"><code class="language-code">x = 0
print(f'x = {x}')   # (1)
if x == 0:
    y = 0
else:
    y = 5 / x          # (2)
print(f'y = {y}') </code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
x = 0
y = 0</code></pre>
<p>Такие решения должны быть тщательно продуманы и согласованы с бизнес-требованиями. Возможно, что в
подобной ситуации заказчик  ожидает, что программа аварийно завершит работу. Тогда данное 
решение приведет к <strong>сокрытию</strong> ошибки, которая может потом проявиться в других частях программы.
В языке Python есть специальный способ обработки ошибок.</p>
<pre class="highlight"><code class="language-code">x = 0
print(f'x = {x}')   # (1)
try: 
    y = 5 / x 
except ZeroDivisionError:
    y = 0       # (2)
print(f'y = {y}') </code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
x = 0
y = 0</code></pre>
<p>Блок <code>try - except</code> (защищенный блок) определяет фрагмент программы, в котором ошибки не будут
сразу вызывать аварийное завершение всей программы. В блоке <code>except</code> есть возможность каким-то
образом устранить последствия ошибки и/или бросить тоже самое или другое исключение.</p>
<p>В данном примере указана конкретная ошибка <code>ZeroDivisionError</code>, которая будет "отлавливаться", 
если конкретную ошибку не указать, то будут отлавливаться все ошибки.</p>
<p>В следующей задаче вводится массив чисел и некоторое число <code>x</code>. Требуется вывести все индексы числа 
<code>x</code> в массиве. Если таковых нет, то вывести "None".</p>
<pre class="highlight"><code class="language-code">lst = [int(i) for i in input().split()]
x = int(input())
i = -1
while True:
    try:
        i = lst.index(x, i + 1)
    except:
        if i &lt; 0:
            print("None")
        break
    print(i, end=' ')</code></pre>
<p>Метод списка <code>index()</code> возвращает первый индекс заданного значения в массиве,
а если такого значения нет, то завершается исключением (ошибкой). В данном случае нам <strong>требуется</strong>
перехватывать исключения для корректного решения задачи. </p>
<hr />
<p><img src="../pict/indents.png" class="floatRight" /></p>
<p><a name="index_entry_i_52"></a> </p>
<h1 id="_45">Отступы</h1>
<p>В языке Python отступы используются для структурных частей программы. В отличии от многих других 
языков программирования, в ввиду отсутствия операторных скобок, отступы  и переводы строк являются 
значимыми элементами программного кода. То есть <strong>изменения отступа изменяет поведение программы</strong>.
Рассмотрим пример. Следующая программа определяет являются ли элементы списка частью арифметической 
прогрессии. </p>
<p><a name="index_entry_i_53"></a>
Алгоритм работы программы изобразим в виде <em>блок-схемы</em>, которая иллюстрирует последовательность
выполнения действий и необязательно привязана к конкретному языку. В данном случае блок-схема
определяет отдельные операции ввода и вывода данных, которые мы планируем реализовать в более 
простом виде.</p>
<p style="clear: both;"></p>

<pre class="highlight"><code class="language-code">def is_range(sek):                             # (1)
    if len(sek) &lt; 3:                           # (2)
        return 'NO'                            # (3)
    delta = sek[1] - sek[0]                    # (4)
    for i in range(2, len(sek)):               # (5)
        if sek[i]- sek[i - 1] != delta:        # (6)
            return 'NO'                        # (7)
    return 'YES'                               # (8)

print(is_range([2, 5, 8, 11]))                 # (9)</code></pre>
<p>(1) &mdash; начинается определение функции. Нулевой отступ говорит о том, что это будет обязательно 
выполнено при исполнении модуля ( файла в котором находится этот код). Код в строках  (2...8)
является подчиненным к строке (1). Поэтому строки (1...8) можно условно считать одной ( хотя и 
составной) инструкцией. Следующая инструкция в таком случае, можно считать код в строке (9).</p>
<p>(2) &mdash; один отступ ( 4 пробела). Первая инструкция внутри функции, будет обязательно исполнена при 
вызове функции.</p>
<p>(3) &mdash; тело условия, один отступ внутри родительского (условного) блока, всего два отступа. Данная 
инструкция <code>return</code>, будет выполнена только при определенном условии.</p>
<p>(4) &mdash; один отступ. т. е. можно считать следующим оператором после <code>if</code> (2). В данном случае он 
может не выполниться, если предыдущее условие окажется верным и выполнение функции завершится.
Однако если выполнение функции попадет в строку (4), то эта строка точно будет выполнена. </p>
<div class="admonition danger">
<p class="admonition-title">Возможные ошибки</p>
<p>Если в строке (4) добавить еще один отступ то, она окажется в блоке <code>if</code> после оператора 
<code>return</code>, что в данном случае не имеет смысла потому что после оператора <code>return</code> функция 
завершает выполнение.</p>
<p>К тому же, если условие окажется ложным то (4) строка не выполнится. Следовательно переменная
<code>delta</code> не будет определена, что приведет к ошибке ее использования в строке (6).</p>
</div>
<p>(5) &mdash; один отступ, цикл точно будет выполнен после строки (4).</p>
<p>(6, 7) &mdash; тело цикла, один отступ внутри родительского блока <code>for</code>, итого соответственно 
2 и 3 отступа. Здесь рассуждения те же самые, что и внутри строк (3, 4).</p>
<p>(8) &mdash; один отступ, может быть выполнена <strong>после завершения цикла  for</strong>.  В данном случае внутри 
цикла может произойти возврат значения и, соответственно, завершения работы функции. В этом случае
строка (8) выполнена не будет.   </p>
<div class="admonition danger">
<p class="admonition-title">Возможные ошибки</p>
<p>Если добавить строке (8) еще два отступа, то ошибка будет аналогична предыдущей. Только в 
данном случае ошибки в выполнении не произойдет и программа вместо ответа <code>"Yes"</code> выдаст ответ
<code>None</code>. А это явно не то что нам нужно.</p>
<p>Если в строку (4) добавить один дополнительный отступ, то тогда тело цикла выполнится не более 
одного раза, т. е. будут проверены не все элементы. Это явно не то, что нам нужно.</p>
</div>
<p>(9) &mdash; нулевой отступ, будет обязательно выполнена при исполнении текущего модуля (если, конечно, 
определение функции пройдет без ошибок).</p>
<hr />
<p><a name="index_entry_i_54"></a> </p>
<h1 id="_46">Методы строк</h1>
<h2 id="_47">Поиск и замена</h2>
<p>Методы поиска и замены строк внутри других строк.</p>
<p>Каждый метод в этой группе поддерживает необязательные аргументы <start> и <end>. Как и в 
строковых срезах действие метода ограничено частью исходной строки, начинающейся с позиции 
символа <start> и продолжающейся вплоть до позиции символа <end>, но не включающей ее. Если 
параметр <start> указан, а параметр <end> нет, то метод применяется к части исходной строки от 
<start> до конца строки. Если параметры не заданы, то подразумевается, что <start> = 0 , 
<end> = len(s).</p>
<table>
<thead>
<tr>
<th>Функция</th>
<th>Значение</th>
<th>Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count()</code></td>
<td>считает количество непересекающихся вхождений подстроки в исходную строку</td>
<td></td>
</tr>
<tr>
<td><code>startswith()</code></td>
<td>определяет начинается ли исходная строка s подстрокой <code>prefix</code></td>
<td>True/False</td>
</tr>
<tr>
<td><code>endswith()</code></td>
<td>определяет оканчивается ли исходная строка s подстрокой <code>suffix</code></td>
<td>True/False</td>
</tr>
<tr>
<td><code>find()</code></td>
<td>находит индекс первого вхождения подстроки <code>sub</code> в исходной строке s</td>
<td>-1/ индекс</td>
</tr>
<tr>
<td><code>rfind()</code></td>
<td>он ищет первое вхождение подстроки начиная с конца строки s, если нет то</td>
<td>-1/ индекс</td>
</tr>
<tr>
<td><code>strip()</code></td>
<td>возвращает копию строки s у которой удалены все пробелы стоящие в начале и конце строки</td>
<td></td>
</tr>
<tr>
<td><code>lstrip()</code></td>
<td>возвращает копию строки s у которой удалены все пробелы стоящие в начале строки</td>
<td></td>
</tr>
<tr>
<td><code>rstrip()</code></td>
<td>возвращает копию строки s у которой удалены все пробелы стоящие в конце строки</td>
<td></td>
</tr>
<tr>
<td><code>replace()</code></td>
<td>возвращает копию s со всеми вхождениями подстроки <code>old</code>, замененными на <code>new</code></td>
<td></td>
</tr>
</tbody>
</table>
<p><a name="index_entry_i_55"></a>   <br />
s = 'abcdefghij'</p>
<table>
<thead>
<tr>
<th>Программный код</th>
<th>Результат</th>
<th>Пояснение</th>
</tr>
</thead>
<tbody>
<tr>
<td>s[2:5]</td>
<td>cde</td>
<td>строка состоящая из символов с индексами 2, 3, 4</td>
</tr>
<tr>
<td>s[:5]</td>
<td>abcde</td>
<td>первые пять символов строки</td>
</tr>
<tr>
<td>s[5:]</td>
<td>fghij</td>
<td>строка состоящая из символов с индексами от 5 до конца</td>
</tr>
<tr>
<td>s[-2:]</td>
<td>ij</td>
<td>последние два символа строки</td>
</tr>
<tr>
<td>s[:]</td>
<td>abcdefghij</td>
<td>вся строка целиком</td>
</tr>
<tr>
<td>s[1:7:2]</td>
<td>bdf</td>
<td>строка состоящая из каждого второго символа с индексами от 1 до 6</td>
</tr>
<tr>
<td>s[::-1]</td>
<td>jihgfedcba</td>
<td>строка в обратном порядке, так как шаг отрицательный</td>
</tr>
</tbody>
</table>
<p>S.isdigit() Состоит ли строка из цифр</p>
<p>S.isalpha() Состоит ли строка из букв</p>
<p>S.isalnum() Состоит ли строка из цифр или букв</p>
<p>S.islower() Состоит ли строка из символов в нижнем регистре</p>
<p>S.isupper() Состоит ли строка из символов в верхнем регистре</p>
<p>S.isspace() Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), 
"новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная 
табуляция" ('\v'))</p>
<p>S.istitle() Начинаются ли слова в строке с заглавной буквы</p>
<p>S.upper() Преобразование строки к верхнему регистру</p>
<p>S.lower() Преобразование строки к нижнему регистру</p>
<p>S.join(список) Сборка строки из списка с разделителем S</p>
<p>ord(символ) Символ в его код ASCII</p>
<p>chr(число) Код ASCII в символ</p>
<p>S.capitalize() Переводит первый символ строки в верхний регистр, а все остальные в нижний</p>
<p>S.center(width, [fill]) Возвращает отцентрованную строку, по краям которой стоит символ fill 
(пробел по умолчанию)</p>
<p>S.count(str, [start],[end]) Возвращает количество непересекающихся вхождений подстроки в диапазоне 
[начало, конец] (0 и длина строки по умолчанию)</p>
<p>S.expandtabs([tabsize]) Возвращает копию строки, в которой все символы табуляции заменяются одним 
или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер 
табуляции полагается равным 8 пробелам</p>
<p>S.partition(шаблон) Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть 
после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две 
пустых строки</p>
<p>S.rpartition(sep) Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть 
после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем 
саму строку</p>
<p>S.swapcase() Переводит символы нижнего регистра в верхний, а верхнего – в нижний</p>
<p>S.title() Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний</p>
<p>S.zfill(width) Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями</p>
<p>S.ljust(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя 
последние символы символом fillchar</p>
<p>S.rjust(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя первые 
символы символом fillchar </p>
<p><a name="index_entry_i_56"></a> </p>
<h2 id="_48">Регулярные выражения</h2>
<p>Википедия: <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">Регулярные выражения</a>:</p>
<blockquote>
<p>Регулярные выражения (англ. regular expressions) — формальный язык, используемый в компьютерных 
программах, работающих с текстом, для поиска и осуществления манипуляций с подстроками в тексте, 
основанный на использовании <em>метасимволов</em>.</p>
</blockquote>
<p>Подходящий материал по использованию регулярных выражений в языке Python см. 
<a href="https://www.w3schools.com/python/python_regex.asp">здесь</a>.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; import re
&gt;&gt;&gt; txt = "The rain in Spain"
&gt;&gt;&gt; pattern = re.compile("^The.*Spain$")
&gt;&gt;&gt; re.search(pattern, txt)
&lt;re.Match object; span=(0, 17), match='The rain in Spain'&gt;</code></pre>
<p>В данном примере используются следующие метасимволы: </p>
<ul>
<li><code>^</code> &mdash; обозначает начало строки;</li>
<li><code>$</code> &mdash; обозначает конец строки;</li>
<li><code>.</code> &mdash; обозначает один любой символ;</li>
<li><code>*</code> &mdash; обозначает повторение предыдущего символа ноль или несколько раз.</li>
</ul>
<p>Остальные символы в данном примере обозначают сами себя. </p>
<p>Рассмотрим простой пример замены:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; pattern = re.compile("[ .,-]")
&gt;&gt;&gt; txt = "  I love - my cat, ."
&gt;&gt;&gt; re.sub(pattern, '', txt)
'Ilovemycat'</code></pre>
<p>В данном примере используется еще один метасимвол &mdash; <code>[]</code>, который обозначает один из перечисленных 
символов. Здесь мы выполняем удаление (т.е. замену на пустую строку) всех пробелов и некоторых 
знаков препинания. </p>
<p>Более подробную информацию можно легко найти в интернете, в т.ч. по указанным выше ссылкам.</p>
<p>Немного модифицированный вариант использования см. <a href="problems/4_python_drill.html#palindrome">здесь</a>.</p>
<p>&nbsp;</p>
<hr />

<p style="margin-top:0px;margin-bottom:0px;text-align:right;"><a href="python_working_environment.html" 
title="Previous: Рабочая среда Python"><img src="../layout/pict/previous_page.png"/></a>

<a href="programming_techniques.html" title="Next: Приемы программирования"><img 
src="../layout/pict/next_page.png"/></a>
</p>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>
</html>
