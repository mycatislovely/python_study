<!DOCTYPE html>
<html>
<head><title>4 Python drill</title>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/png" href="../../pict/favicon.png"/>
<link rel="stylesheet" type="text/css" href="../../layout/styles.css"/>
<link rel="stylesheet" type="text/css" href="../../layout/layout.css"/>
<link rel="stylesheet" type="text/css" href="../../theme.css"/>

<style>
.headerNavArrows {position: relative; top: 3px;}
</style>
</head>
<body>

<div class="header"><b><span style="color:#59f;margin-right:7px;">Py</span></b><a 
class="header_item" href="../index_page.html">Index</a><a 
class="header_item" href="../todo_page.html">TODO</a><a 
class="header_item" href="../problems_page.html">Задачи</a><a 
class="header_item" href="https://github.com/alovemycat/python_study">GitHub</a>

<a href="../../../doc_src/problems/4_python_drill.txt " class="header_item_source" title="Source text">&lt;/&gt;</a>


<a href="3_final_tasks.html" title="Previous: 3 Итоговые задачи"><img class="headerNavArrows" src="../../layout/pict/previous_page_h18px.png"/></a>

<a href="5_chess.html" title="Next: 5 Шахматы"><img class="headerNavArrows" src="../../layout/pict/next_page_h18px.png"/></a>


<span class="headerTitle">4 Python drill</span>

</div>

<div class="sidebar">
    <table class="sidebarAligner">
        <tr><td valign="top">
            <div class="sidebar_item"><a href="../about.html">Введение</a></div>
<div class="sidebar_item"><a href="../architecture.html">Основы программирования</a></div>
<div class="sidebar_item"><a href="../program_design.html">Проектирование программ</a></div>
<div class="sidebar_item"><a href="../command_line_work.html">Работа в командной строке</a></div>
<div class="sidebar_item"><a href="../related_technologies.html">Сопутствующие технологии</a></div>
<div class="sidebar_item"><a href="../python_working_environment.html">Рабочая среда Python</a></div>
<div class="sidebar_item"><a href="../python_program_elements.html">Элементы программы на языке Python</a></div>
<div class="sidebar_item"><a href="../programming_techniques.html">Приемы программирования</a></div>
<div class="sidebar_item"><a href="../algorithms_and_data_structures.html">Алгоритмы и структуры данных</a></div>
<div class="sidebar_item"><a href="../technical_English.html">Technical English</a></div>
            <h3>Задачи</h3>
            <div class="sidebar_item"><a href="01_12_intro.html">1 Основы</a></div>
<div class="sidebar_item"><a href="2_lists .html">2 Циклы, строки, списки</a></div>
<div class="sidebar_item"><a href="3_final_tasks.html">3 Итоговые задачи</a></div>
<div class="sidebar_item selected"><a href="4_python_drill.html">4 Python drill</a></div>
<div class="sidebar_item"><a href="5_chess.html">5 Шахматы</a></div>
<div class="sidebar_item"><a href="mini_projects.html">6 Мини проекты</a></div>
            <h3>Useful links</h3>
            <div class="sidebar_item"><a href="https://www.python.org/">Python</a></div>
<div class="sidebar_item"><a href="https://git-scm.com/">Git</a></div>
        </td></tr>
        <tr><td class="bottom" valign="bottom">
            Generated by md2html_py 1.0.2
            <br />2023-03-13 20:55:35
        </td></tr>
    </table>
</div>

<p style="font-size:44px;font-weight:bold;margin:0 0 30px 0;">4 Python drill</p>

<div class="toc">
<ul>
<li><a href="#_1">Римские числа</a></li>
<li><a href="#_2">Римские цифры</a></li>
<li><a href="#_3">Транспонирование матрицы</a></li>
<li><a href="#_4">Анаграмма</a></li>
<li><a href="#_5">Статистика длины слова</a></li>
<li><a href="#_6">Число из римской цифры</a></li>
<li><a href="#_7">Преобразование единиц длины</a></li>
<li><a href="#_8">Номер купе</a></li>
<li><a href="#_9">Ханойская башня</a></li>
<li><a href="#_10">Проверка арифметической прогрессии</a></li>
<li><a href="#_11">Часто встречающиеся слова</a></li>
<li><a href="#_12">Генерирует последовательность чисел</a></li>
<li><a href="#fizz-buzz">Fizz Buzz</a></li>
<li><a href="#_13">Шифр Цезаря</a></li>
<li><a href="#_14">Фрактал Коха</a></li>
<li><a href="#game-of-life">Game of life</a></li>
<li><a href="#google-search">Google search</a></li>
<li><a href="#ip-">Проверка IP-адреса</a></li>
<li><a href="#_15">Надежность пароля</a></li>
<li><a href="#_16">Слияние отсортированных списков</a></li>
<li><a href="#_17">Палиндром</a></li>
<li><a href="#_18">Правильная скобочная последовательность</a></li>
<li><a href="#_19">Змеиный регистр</a></li>
<li><a href="#_20">Кеширование</a></li>
</ul>
</div>
<hr />
<p><a name="index_entry_p_1"></a>
<a name="rome_number"></a></p>
<h1 id="_1">Римские числа</h1>
<p>В римской системе счисления для обозначения чисел используются следующие символы 
(справа записаны числа, которым они соответствуют в десятичной системе счисления):</p>
<ul>
<li>I = 1</li>
<li>V = 5</li>
<li>X = 10</li>
<li>L = 50</li>
<li>C = 100</li>
<li>D = 500</li>
<li>M = 1000</li>
</ul>
<p>Будем использовать вариант, в котором числа 4, 9, 40, 90, 400 и 900 записываются как вычитание из 
большего числа меньшего: IV, IX, XL, XC, CD и CM, соответственно.</p>
<p>Формат ввода: строка, содержащая натуральное число n, 0 &lt; n &lt; 4000.</p>
<p>Формат вывода: строка, содержащая число, закодированное в римской системе счисления.</p>
<pre class="highlight"><code class="language-code">d =[['', 'I','II','III','IV', 'V', 'VI','VII','VIII','IX'],
    ['', 'X','XX','XXX','XL','L','LX','LXX','LXXX','XC'],
    ['', 'C','CC','CCC','CD','D','DC','DCC','DCCC','CM'],
    ['', 'M','MM','MMM']]

def rome_number(n):
    a = 0
    result = []
    while n &gt; 0:
        i = n % 10
        n //= 10
        result.append(d[a][i])  # Заполняем список
        a += 1
    result.reverse()  # Переворачиваем список на месте
    return ''.join(result)  # Соединяем все элементы списка в строку 

if __name__ == "__main__":        
    print(rome_number(int(input())))</code></pre>
<p>Выполнение: </p>
<pre class="highlight"><code class="language-shell">&gt;echo 3 | python rome_number.py
III

&gt;echo 5 | python rome_number.py
V

&gt;echo 1247 | python rome_number.py
MCCXLVII</code></pre>
<p><a name="index_entry_p_2"></a>
Для этой функции был создан юни-тест, который проверил ее на ошибки.</p>
<pre class="highlight"><code class="language-code">import unittest
import rome_number as lib


class TestRomeNumber(unittest.TestCase):

    def test_7(self):
        self.assertEqual('VII', lib.rome_number(7))

    def test_multiple(self):
        for n, r in [(3, 'III'), (15, 'XV'), (1230, 'MCCXXX'), (78, 'LXXVIII'), (1, 'I'), 
                     (412, 'CDXII'), (105, 'CV'), (1700, 'MDCC'), (3911, 'MMMCMXI')]:
            with self.subTest(test_name=n):
                self.assertEqual(r, lib.rome_number(n))


if __name__ == "__main__":
    unittest.main()</code></pre>
<pre class="highlight"><code class="language-shell">&gt;python test_rome_number.py
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</code></pre>
<p>Если тест находит ошибки, он подробно указывает где и что вызвало ошибку.</p>
<pre class="highlight"><code class="language-shell">&gt;python test_rome_number.py
..F.
======================================================================
FAIL: test_700 (__main__.TestRomeNumber)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_rome_number.py", line 14, in test_700
    self.assertEqual('DCCI', lib.rome_number(700))
AssertionError: 'DCCI' != 'DCC'
- DCCI
?    -
+ DCC</code></pre>
<p>Исходный код программы: <a href="../../../code/problems/python_drill/rome_number.py">rome_number.py</a>.</p>
<hr />
<p><a name="index_entry_p_3"></a></p>
<h1 id="_2">Римские цифры</h1>
<p>Напишите программу, которая считывает целое число и выводит соответствующую ему римскую цифру. 
Если число находится вне диапазона 1-10, то программа должна вывести текст «ошибка».</p>
<pre class="highlight"><code class="language-code">d = ['', 'I','II','III','IV', 'V', 'VI','VII','VIII','IX', 'X']
x = int(input())
print(d[x] if 1 &lt;= x &lt;= 10 else 'ошибка')</code></pre>
<hr />
<p><a name="index_entry_p_4"></a>
<a name="transpond_matrix"></a></p>
<h1 id="_3">Транспонирование матрицы</h1>
<p>Программа считывает из консоли следующие строки:</p>
<ul>
<li>размерность матрицы в виде двух чисел разделенных пробелом,</li>
<li>последующие строки &mdash; сама матрица в виде строк, в которых элементы разделены пробелом.</li>
</ul>
<p>После считывания строк программа выводит в консоль <em>транспонированную</em> матрицу, так же в виде строк, 
в которой элементы разделены пробелами.</p>
<p><em>Транспонирование</em> можно представить, как перестроение матрицы путем смены расположения 
строк и столбцов.</p>
<p>Входные данные:</p>
<pre class="highlight"><code>3 2
1 2 3
4 5 6 </code></pre>
<p>Выходные данные</p>
<pre class="highlight"><code>1 4
2 5
3 6</code></pre>
<p><strong>Декомпозиция</strong>. Оформим решение в виде трех функций:</p>
<ul>
<li>вводит матрицу из консоли;</li>
<li>принимает и транспонирует матрицу;</li>
<li>принимает на вход матрицу и печатает ее в консоль.</li>
</ul>
<p>Исходный код программы: <a href="../../../code/problems/python_drill/transpond_matrix.py">transpond_matrix.py</a>.</p>
<p><img alt="" src="../../pict/transpond_matrix.png" /></p>
<pre class="highlight"><code class="language-code">def input_matrix():
    x, y = [int(i) for i in input().split()] 
    return [[i for i in input().split()]for _ in range(y)]

def transpond_matrix(m):
    y = len(m)
    x = len(m[0]) if y &gt; 0 else 0
    m1 = []
    for i in range(x):
        m1.append([m[j][i] for j in range(y)])
    return m1

def print_matrix(m):
    for line in m: 
        for cell in line:
            print(str(cell).rjust(3, ' '), end=" ")
        print()</code></pre>
<p>Исходный код программы: <a href="../../../code/problems/python_drill/transpond_matrix_demo.py">transpond_matrix_demo.py</a>.</p>
<pre class="highlight"><code class="language-code">import transpond_matrix as lib

m = lib.input_matrix()
lib.print_matrix(m)
print('-------------------------')
m1 = lib.transpond_matrix(m)
lib.print_matrix(m1)</code></pre>
<p>Входные данные : <a href="../../../code/problems/python_drill/transpond_matrix_input.txt">transpond_matrix_input.txt</a>.</p>
<pre class="highlight"><code>4 3
1 2 3 4
5 6 7 8
9 10 11 12</code></pre>
<p>Выполнение:</p>
<pre class="highlight"><code class="language-shell">&gt;python transpond_matrix.py &lt; transpond_matrix_input.txt
  1   2   3   4
  5   6   7   8
  9  10  11  12
-------------------------
  1   5   9
  2   6  10
  3   7  11
  4   8  12</code></pre>
<p>Тестирование  функции <code>transpond_matrix</code>.</p>
<p>Исходный код программы: <a href="../../../code/problems/python_drill/test_transpond_matrix.py">transpond_matrix.py</a>.</p>
<hr />
<p><a name="index_entry_p_5"></a>
<a name="is_anagram"></a></p>
<h1 id="_4">Анаграмма</h1>
<p>Напишите программу, которая проверяет, являются ли два введённых слова анаграммами. Регистр 
символов не должен влиять на ответ.</p>
<pre class="highlight"><code class="language-code">import unittest

def is_anagram(s1, s2):
    return sorted(s1.lower()) == sorted(s2.lower())

class TestIsAnagram(unittest.TestCase):

    def test_empty_strings(self):
        self.assertTrue(is_anagram('', ''))

    def test_positive(self):
        self.assertTrue(is_anagram('кот', 'кто'))

    def test_any_case(self):
        self.assertTrue(is_anagram('AbaCa', 'AcaBa'))   

    def test_negative(self):
        self.assertFalse(is_anagram('gbaba', 'acada'))  

if __name__ == "__main__":
    unittest.main()</code></pre>
<pre class="highlight"><code class="language-shell">&gt;python anagram.py
....
----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK</code></pre>
<p>Исходный код программы: <a href="../../../code/problems/python_drill/anagram.py">anagram.py</a>.</p>
<hr />
<p><a name="index_entry_p_6"></a></p>
<h1 id="_5">Статистика длины слова</h1>
<p>На вход программе подаётся строка, содержащая слова, разделённые пробелом. Программа должна вывести 
статистику длин слов в полученной строке, от меньшей длины слова к большей (см. пример).</p>
<p>Словом считается последовательность произвольных символов, окружённая пробелами либо границами 
строки. Заметьте, что знаки препинания также относятся к слову.</p>
<p>Формат ввода:
Одна строка, содержащая последовательности латинских символов и знаков препинания, разделённые 
пробелом.</p>
<p>Формат вывода:
Для каждой длины слова, встречающейся в исходной строке, нужно указать количество слов с такой длиной
длина: количество
Статистика должна выводиться в порядке увеличения длины.</p>
<pre class="highlight"><code class="language-code">a = input().split()
d = {}
for w in a:
    l = len(w)
    d[l] = d.get(l, 0) + 1
for l, n in sorted(d.items()):
    print(l, n, sep=':')</code></pre>
<p>Входные данные:</p>
<pre class="highlight"><code>Beautiful is better than ugly. Explicit is better than implicit.</code></pre>
<pre class="highlight"><code class="language-shell">2: 2
4: 2
5: 1
6: 2
8: 1
9: 2</code></pre>
<hr />
<p><a name="index_entry_p_7"></a></p>
<h1 id="_6">Число из римской цифры</h1>
<p>В римской системе счисления для обозначения чисел используются следующие символы 
(справа записаны числа, которым они соответствуют в десятичной системе счисления):</p>
<p>I = 1
V = 5
X = 10
L = 50
C = 100
D = 500
M = 1000
Будем использовать вариант, в котором числа 4, 9, 40, 90, 400 и 900 записываются как вычитание из 
большего числа меньшего: IV, IX, XL, XC, CD и CM, соответственно.</p>
<p>Напишите программу, которая переводит число из римской в десятичную систему счисления.</p>
<p>Формат ввода:
Строка, содержащая число, закодированное в римской системе счисления. Гарантируется, что число 
меньше 4000.</p>
<p>Формат вывода:
Строка, содержащая число в десятичной системе счисления, соответствующее введённому.</p>
<pre class="highlight"><code class="language-code">d = {'M':1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}

def rome_to_decimal(f):
    n = 0
    p = 0
    for c in reversed(f):
        v = d[c] 
        if v &gt;= p:
            n += v
        else:
            n -= v
        p = v
    return n

print(rome_to_decimal(input()))</code></pre>
<p>Входные данные:</p>
<pre class="highlight"><code>MCMLXXXIV</code></pre>
<pre class="highlight"><code class="language-shell">1984</code></pre>
<p>Исходный код программы: <a href="../../../code/problems/python_drill/rome_to_decimal.py">rome_to_decimal.py</a>.</p>
<hr />
<p><a name="index_entry_p_8"></a>
<a name="index_entry_i_1"></a></p>
<h1 id="_7">Преобразование единиц длины</h1>
<p><a href="https://metanit.com/python/tutorial/5.3.php">Дробное число в научном формате</a></p>
<p>Требуется написать программу, осуществляющую преобразование из одних единиц измерения длины в другие. </p>
<p>Должны поддерживаться</p>
<p>мили (1 mile = 1609 m), 
ярды (1 yard = 0.9144 m), 
футы (1 foot = 30.48 cm), 
дюймы (1 inch = 2.54 cm), 
километры (1 km = 1000 m), 
метры (m), 
сантиметры (1 cm = 0.01 m)
миллиметры (1 mm = 0.001 m)
Используйте именно указанные в формулировке задачи единицы измерения с указанной точностью.</p>
<p>Формат ввода:
Одна строка с фразой следующего вида:
<number> <unit_from> in <unit_to>
например, если пришла фраза "15.5 mile in km", то требуется перевести 15.5 миль в километры.</p>
<p>Формат вывода:
Дробное число в научном формате (экспоненциальном), с точностью ровно два знака после запятой.</p>
<pre class="highlight"><code class="language-code">d = {'mile': 1609, 'yard': 0.9144, 'foot': 0.3048, 'inch': 0.0254, 'km': 1000, 
     'm': 1, 'cm': 0.01, 'mm': 0.001}

x, f, _, t = input().split()

print("{:.2e}".format(float(x) * d[f] / d[t]))</code></pre>
<p>Входные данные:</p>
<pre class="highlight"><code>15.5 mile in km</code></pre>
<pre class="highlight"><code class="language-shell">2.49e+01</code></pre>
<p>Другой пример:</p>
<p>Напишите программу, которая вычисляет долю студентов, получивших оценку A.
Используется пятибалльная система оценивания с оценками A, B, C, D, F.</p>
<p>Строка, в которой через пробел записаны оценки студентов. Оценок всегда не меньше одной.</p>
<p><strong>Формат вывода:</strong>
Дробное число с ровно двумя знаками после запятой.</p>
<pre class="highlight"><code class="language-code">b = input().split()
cnt = 0
for n in b:
    if n == 'A':
        cnt += 1
    r = cnt / len(b) 
print("{:.2f}".format(float(r)))</code></pre>
<p>Более короткий вариант решения:</p>
<pre class="highlight"><code class="language-code">sp = input().split()
print('{:.2f}'.format(sp.count('A') / len(sp)))</code></pre>
<p>В данном решении используется <code>Counter</code>— это <code>dict</code> подкласс для подсчета объектов. Это коллекция, 
в которой элементы хранятся как ключи словаря, а их счетчики хранятся как значения словаря. 
Подсчеты могут быть любыми целыми значениями, включая нулевые или отрицательные подсчеты. 
Класс Counter подобен <em>мультимножествам</em> в других языках.</p>
<hr />
<p>!--p ["номер купе"]--&gt;</p>
<h1 id="_8">Номер купе</h1>
<p>В купейном вагоне имеется 99 купе с четырьмя местами для пассажиров в каждом. Напишите программу, 
которая определяет номер купе, в котором находится место с заданным номером (нумерация мест 
сквозная, начинается с 1).</p>
<p>На вход программе подаётся целое число – место с заданным номером в вагоне.</p>
<p>Программа должна вывести одно число – номер купе, в котором находится указанное место.</p>
<p><img alt="" src="../../pict/kupe.png" /></p>
<pre class="highlight"><code class="language-code">print((int(input())-1) // 4 + 1)</code></pre>
<p>Входные данные:</p>
<pre class="highlight"><code>2</code></pre>
<pre class="highlight"><code class="language-shell">1</code></pre>
<hr />
<p><a name="index_entry_p_9"></a>
<a name="hanoi"></a><a name="index_entry_i_2"></a></p>
<h1 id="_9">Ханойская башня</h1>
<p>Также см. <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BD%D0%BE%D0%B9%D1%81%D0%BA%D0%B0%D1%8F_%D0%B1%D0%B0%D1%88%D0%BD%D1%8F">Википедию</a>.</p>
<p>Есть 1 стержень с дисками разного размера, и еще 2 пустых стержня. Надо переместить диски с одного 
стержня на другой. Перекладывать можно только по одному диску за ход. Складывать диски можно 
только меньший на больший. Требуется написать программу для перекладывания дисков.</p>
<pre class="highlight"><code class="language-code">def hanoi(n, s1, s2, s3):
    if n &lt; 1:
        return
    elif n &lt; 2:
        yield s1, s3
    else:
        yield from hanoi(n-1, s1, s3, s2) # разворачивает генератор как for и возвращает значение
        yield s1, s3
        yield from hanoi(n-1, s2, s1, s3)</code></pre>
<p>Подход к тестированию данного решения рассмотрен <a href="../program_design.html#test_hanoi">здесь</a>.
Ниже представлен готовый тестировочный код:</p>
<pre class="highlight"><code class="language-code">def test_hanoi(n, s1, s2, s3):
    sticks = [[], [], []]
    #  Заполняем массив с индексом s1 числами от `n` до 1 и в убывающем порядке.
    stick = sticks[s1]
    for i in range(n, 0, -1):
        stick.append(i)
    #  Выполняем перекладывания и проверки. 
    i = 0    
    for s_from, s_to in hanoi(n, s1, s2, s3):
        # s_to = 2  #  "вредоносный" код для проверки самого теста.
        i = i + 1
        disk = sticks[s_from].pop() #  сняли диск с первого стержня.
        stick_to = sticks[s_to]  # стержень, на который перекладываем.
        if len(stick_to) &gt; 0:  # массив stick_to не пустой.
            over = stick_to[len(stick_to) - 1]  # диск, на который перекладываем.   
            if disk &gt;= over:
                print(f"Eror: arguments n={n}, s1={s1}, s2={s2}, s3={s3}, step {i}, " 
                      f"disk {disk} over {over}")
                return
        stick_to.append(disk)  # добавление значения в массив (append)
    # проверяем, что в массиве с индексом s3 находится `n` элементов. 
    if len(sticks[s3]) != n:        
        print(f"Eror: arguments n={n}, s1={s1}, s2={s2}, s3={s3}, final height " 
                      f"is {len(sticks[s3])}")</code></pre>
<p>Исходный код программы: <a href="../../../code/problems/python_drill/hanoi.py">hanoi.py</a>.</p>
<hr />
<p><a name="index_entry_p_10"></a></p>
<!--арифметическая прогрессия -->
<h1 id="_10">Проверка арифметической прогрессии</h1>
<p>Напишите программу, которая определяет, являются ли три заданных числа (в указанном порядке) 
последовательными членами арифметической прогрессии.</p>
<p>На вход программе подаются три числа, каждое на отдельной строке.</p>
<p>Программа должна вывести «YES» или «NO» (без кавычек) в соответствии с условием задачи. </p>
<pre class="highlight"><code class="language-code">def is_range(sek):
    if len(sek) &lt; 3:
        return 'NO'
    delta = sek[1] - sek[0]
    for i in range(2, len(sek)):
        if sek[i]- sek[i - 1] != delta:
            return 'NO'
    return 'YES'    

sek = int(input()),int(input()),int(input())
print(is_range(sek))</code></pre>
<hr />
<p><a name="index_entry_p_11"></a></p>
<h1 id="_11">Часто встречающиеся слова</h1>
<p>Программа читает из файла текст и выводит наиболее часто встречающееся слово.</p>
<pre class="highlight"><code class="language-code">def repeating_word(input_file_name, output_file_name):
    with open(input_file_name, 'r', encoding = 'UTF-8') as f:
        with open(output_file_name, 'w', encoding = 'UTF-8') as o:
            line = f.readline().lower()
            while line:
                line = line.split() 
                s = {}                
                i1=0
                i2=''
                q=0
                t=[]
                min1=0
                for i in line: # ввожу слова в словарь
                    if i not in s: # проверяю есть ли слово в словаре,если есть,то добавляю1 
                        s[i]=1
                    else:
                        s[i]+=1
                for values in s.values(): # нахожу максимальное повторение
                    if values&gt;i1:
                        i1=values
                for keys , values in s.items():
                    if values==i1:
                        min1=keys
                for keys , values in s.items(): # если слова встречаются одинаковое кол-во,
                    if values==i1:              # то находим  лексикографическое первое 
                        if min1&gt;keys:
                            min1=keys
                print(min1,i1)
                line=f.readline().lower()
            f.close()

repeating_word('dataset_3363_3 (6).txt', 'reply_3363_2.txt') 
print_file('reply_3363_2.txt')                </code></pre>
<pre class="highlight"><code class="language-shell">azt 3
cctyxtc 6
uczp 8
tyzu 2
z 6</code></pre>
<pre class="highlight"><code class="language-code">def word_count(file_name):
    d = {}
    with open(file_name, 'r', encoding = 'UTF-8') as f:       
        while True:
            line = f.readline()
            if line == '':
                break
            words = line.lower().split()
            for w in words:  # ввожу слова в словарь
                if w not in d:  # проверяю, есть ли слово в словаре, если нет, то добавляю 
                    d[w] = 1
                else:           # если слово уже есть, то +1 к количеству
                    d[w] += 1  
    return d 


def most_frequent_word(word_counts):
    w_max = ''
    n_max = 0
    for w, n in word_counts.items():
        if n &gt; n_max or n == n_max and w &lt; w_max:
            n_max = n
            w_max = w    
    return w_max, n_max


d = word_count('dataset_3363_3 (6).txt')
# d = word_count('word_count_text.txt')
print(d)
w, n = most_frequent_word(d)
print(w, n)
# with open('word_count.txt', 'w', encoding = 'UTF-8') as o:
    # o.write(w + ' ' + str(n))</code></pre>
<hr />
<p><a name="index_entry_p_12"></a></p>
<h1 id="_12">Генерирует последовательность чисел</h1>
<p>Напишите функцию, которая для заданного натурального числа <code>n</code> генерирует последовательность чисел, 
описанную в гипотезе Коллатца:</p>
<p>Если <code>n</code> четное, то делим его пополам, если нечётное, то умножаем на 3 и прибавляем 1. С итогом 
вычисления снова проделываем эту операцию до тех пор, пока в результате не будет получено число 1.</p>
<p>Предполагается, что подобная последовательность остановится на числе 1 для любого начального 
натурального числа n &gt; 0. </p>
<pre class="highlight"><code class="language-code">def colatc(n):
    limit = 10000  # Гипотеза Коллатца - это гипотеза, поэтому мало ли что........
    cunt = 0
    while True:
        yield n
        cunt += 1
        if cunt &gt; limit:
            raise Exception(f"Результат не достигнут за {limit} шагов")
        if n == 1:
            return
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1 

for n in colatc(int(input())):
    print(n, end = ' ')</code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
17
17 52 26 13 40 20 10 5 16 8 4 2 1</code></pre>
<p>Функция определяет длину последовательности чисел.</p>
<pre class="highlight"><code class="language-code">def colatc_len(n):
    cunt = 0
    for _ in colatc(n):
        cunt += 1
    return cunt

print(colatc_len(1001))</code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
143</code></pre>
<hr />
<p><a name="index_entry_p_13"></a></p>
<h1 id="fizz-buzz">Fizz Buzz</h1>
<p>Напишите программу, которая принимает на вход два целых числа: начало и конец отрезка (оба числа 
входят в отрезок).</p>
<p>Программа должна вывести числа из этого отрезка, но если число делится на 3, то вывести вместо него 
Fizz, если число делится на 5, вывести вместо него Buzz, а если делится и на три, и на 5, то вывести 
вместо этого числа FizzBuzz.</p>
<pre class="highlight"><code class="language-code">n, m = (int(i) for i in input().split())
for i in range(n, m + 1):
    if i % 3 == 0 and i % 5 == 0:
        print('FizzBuzz', end='\n ')
    elif i % 3 == 0:
        print('Fizz', end='\n')
    elif i % 5 == 0:
        print('Buzz', end='\n ')
    else:
        print(i, end='\n ')</code></pre>
<p>Формат ввода:
два целых числа через пробел.</p>
<pre class="highlight"><code>8 16</code></pre>
<p>Формат вывода:
На отдельной строке каждое число из отрезка или слово, его заменяющее.</p>
<pre class="highlight"><code class="language-shell">8
 Fizz
Buzz
 11
 Fizz
13
 14
 FizzBuzz
 16</code></pre>
<hr />
<p><a name="index_entry_p_14"></a><a name="caesar"></a></p>
<h1 id="_13">Шифр Цезаря</h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Есть другая реализация этой задачи <a href="mini_projects.html#caesar1">здесь</a>.</p>
</div>
<p>Шифр Цезаря заключается в замене каждого символа входной строки на символ, находящийся на несколько 
позиций левее или правее его в алфавите.</p>
<p>Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита 
применить единичный сдвиг, то он заменится на первый символ, и наоборот.</p>
<p>Напишите программу, которая шифрует текст шифром Цезаря.</p>
<p>Используемый алфавит -− пробел и малые символы латинского алфавита: ' abcdefghijklmnopqrstuvwxyz'</p>
<p>Формат ввода:
На первой строке указывается используемый сдвиг шифрования: целое число. Положительное число 
соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования. Ведущие и 
завершающие пробелы не учитывать.</p>
<p>Формат вывода:
Единственная строка, в которой записана фраза: Result: "..." , где вместо многоточия внутри кавычек 
записана зашифрованная последовательность.</p>
<p>Алгоритм решения:</p>
<ul>
<li>обрабатываем входящую строку посимвольно для каждого символа;</li>
<li>определяем позицию каждого символа в алфавите;</li>
<li>выполняем смещение;</li>
<li>по получившемуся индексу находим новый символ, который выводим в качестве ответа.</li>
</ul>
<p>Для решения задачи требуется алфавит, зададим его в виде списка <code>alf</code>, в который эффективно искать 
символ по индексу. Однако, поиск индекса по символу для списка неэффективен. Поэтому сгенерируем 
словарь <code>d</code> на основе имеющегося списка. </p>
<p><pre class="highlight"><code class="language-code">alf = " abcdefghijklmnopqrstuvwxyz"
n = int(input())
s = input().strip()
l = len(alf)
d = {alf[i] : i for i in range(l)}
result = [alf[(d[c] + n) % l] for c in s]
print('Result:',' ','"',''.join(result),'"', sep='')# "lcdpcfdhvdu"</code></pre>
Этот же код мы можем применить и для расшифровки, изменив шаг сдвига на противоположный.</p>
<pre class="highlight"><code class="language-shell">&gt;python fils.py
3
i am caesar
Result: "lcdpcfdhvdu"</code></pre>
<pre class="highlight"><code class="language-shell">Result: "lcdpcfdhvdu"

````shell
&gt;python fils.py
-3
lcdpcfdhvdu
Result: "i am caesar"</code></pre>
<hr />
<p><a name="index_entry_i_3"></a>
<a name="index_entry_p_15"></a></p>
<h1 id="_14">Фрактал Коха</h1>
<p><img src="../../pict/koch.png" class="floatRight" /></p>

<p>Ломаная Коха &mdash; это простой геометрический фрактал. </p>
<p>Строится этот фрактал следующим образом: берётся отрезок, разделяется на три равных части. Вместо 
средней части вставляется два таких же отрезка, поставленные под углом 60 градусов друг к другу 
(см. иллюстрацию, переход от n=0 к n=1). Этот процесс повторяется на каждой итерации: каждый отрезок
заменяется четырьмя.</p>
<p>Напишите программу, которая принимает на вход число n &mdash; количество итераций генерации кривой и 
выводит последовательность углов поворота при рисовании соответствующей линии от начальной точки к 
конечной, без отрыва пера.</p>
<p>Также см. Википедию: </p>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%B2%D0%B0%D1%8F_%D0%9A%D0%BE%D1%85%D0%B0">Кривая Коха</a></li>
<li><a href="https://en.wikipedia.org/wiki/Koch_snowflake">Koch snowflake</a></li>
</ul>
<p style="clear: both;"></p>

<p><img src="../../pict/koch_algorithm.png" class="floatRight" /></p>

<p>Разработаем рекурсивный алгоритм решения задачи. Как мы можем видеть из рисунка, построение фрактала
происходит одинаковым образом на каждом уровне популяции. Рассмотрим два соседних уровня.</p>
<p>1 &mdash; на уровне <code>n</code> происходит вызов уровня <code>n - 1</code>, который выполняет все необходимые повороты.
Уровень <code>n - 1</code> при этом может рекурсивно вызывать более низкие уровни. Уровень <code>0</code> вызовов не
делает.</p>
<p>2 &mdash; уровень <code>n - 1</code> отработал и вернул управление на уровень <code>n</code>. Уровень <code>n</code> делает поворота
на 60 градусов и снова вызывает уровень <code>n - 1</code> (3), который делает то же самое, что и раньше и 
возвращает управление на уровень <code>n</code> (4).</p>
<p>Дальнейшие действия аналогичны и понятны из рисунка. Реализация выглядит так:</p>
<p style="clear: both;"></p>

<pre class="highlight"><code class="language-code">def koch_fractal(n):
    if n &lt; 1:
        return
    yield from koch_fractal(n - 1)
    yield pi / 3  # 60 градусов перевели в радианы
    yield from koch_fractal(n - 1)
    yield -pi * 2 / 3  # -120 градусов
    yield from koch_fractal(n - 1)
    yield pi / 3  # 60 градусов
    yield from koch_fractal(n - 1)</code></pre>
<p>Для визуальной проверки алгоритма используем графическую библиотеку 
<a href="https://docs.python.org/3.8/library/tkinter.html">tkinter</a>. Реализация отрисовки фрактала 
находится в файле <a href="../../../code/problems/python_drill/koch_fractal.py">koch_fractal.py</a>. 
Были получены изображения:</p>
<ul>
<li>фрактала Коха с количеством поколений 3 и 4; </li>
<li>снежинки Коха с количеством поколений 3 и 4.</li>
</ul>
<p><img alt="" src="../../pict/koch_fractal_3.png" /><img alt="" src="../../pict/koch_fractal_4.png" />
<img alt="" src="../../pict/koch_snowflake_3.png" /><img alt="" src="../../pict/koch_snowflake_4.png" /></p>
<hr />
<p><a name="index_entry_i_4"></a>
<a name="index_entry_p_16"></a></p>
<h1 id="game-of-life">Game of life</h1>
<p>Поле представляет собой прямоугольник, причём для крайних клеток поля соседними являются клетки с 
противоположного конца (поле представляет собой тор).</p>
<p>На первой строке указаны два целых числа через пробел -- высота и ширина поля.
В следующих строках подаётся состояние поля. Точка "." обозначает мёртвую клетку, символ "X" − живую. </p>
<p>Следующее состояние поля, используя те же обозначения, что использовались на вводе.</p>
<pre class="highlight"><code class="language-code">def _how_many_alive(m, h, w, y, x):
    top = y - 1
    bottom = (y + 1) % h
    left = x - 1
    right = (x + 1) % w
    return (m[top][left] + m[top][x] + m[top][right] + m[y][right] + 
            m[bottom][right] + m[bottom][left] + m[bottom][x] + m[y][left]) 


def life(m):
    h = len(m)
    w = len(m[0]) if h &gt; 0 else 0
    m1 = [[0] * w for _ in range(h)]
    for y in range(h):
        for x in range(w):
            a = _how_many_alive(m, h, w, y, x)  # Сколько живых вокруг
            if a == 3 and m[y][x] == 0:
                m1[y][x] = 1
            elif 2 &lt;= a &lt;= 3:
                m1[y][x] = m[y][x]
            else:
                m1[y][x] = 0
    return m1

def input_matrix():
    y, x = [int(i) for i in input().split()] 
    return [[1 if c == "X" else 0 for c in input().strip()] for _ in range(y)]    


def print_matrix(m):
    for line in m: 
        for cell in line:
            print("X" if cell == 1 else ".", end="")
        print()

if __name__ == "main":   
    m = input_matrix() 
    m = life(m) 
    print_matrix(m)       </code></pre>
<p>Все решение разделим на три части:</p>
<ul>
<li>прочитать исходную матрицу из консоли;</li>
<li>рассчитать матрицу следующего поколения;</li>
<li>вывести (распечатать) рассчитанную матрицу.</li>
</ul>
<p>Ключевым шагом является расчет матрицы следующего поколения. Следующее поколение формируется <strong>только</strong> 
на  основе исходной матрицы, т.е. изменения сделанные в процессе формирования на результат не влияют.
Например: если некая клетка перекрасилась из белого в черный, то при расчете следующей клетки
эта клетка должна считаться белой, черной она будет считаться в следующем поколении. Проще всего 
реализовать данное правило если мы не будем менять исходную матрицу, а создадим новую и раскрасим
все клетки заново.</p>
<pre class="highlight"><code>5 6
...XX.
.XX...
..X...
XX....
X..XX.</code></pre>
<pre class="highlight"><code>.X..XX
.XX...
X.X...
XXXX.X
XXXXX.</code></pre>
<p><video width="555" height="328" controls class="floatRight">
  <source src="../../pict/life_anime.mp4" type="video/mp4">
Your browser does not support the video tag.
</video></p>
<p>В  файле <a href="../../../code/problems/python_drill/life/life_anime.py"><code>life_anime.py</code></a> находится 
программа, которая выводит анимацию данного алгоритма.</p>
<p style="clear: both;"></p>

<p><img src="../../pict/life_anime.png" class="floatRight" /></p>

<p>Если видео не работает, то можно посмотреть на картинку.</p>
<p style="clear: both;"></p>

<hr />
<p><a name="index_entry_i_5"></a>
<a name="index_entry_p_17"></a></p>
<h1 id="google-search">Google search</h1>
<p>На вход программе подается натуральное число n, затем n строк, затем число k — количество 
поисковых запросов, затем k строк — поисковые запросы. Напишите программу, которая выводит все 
введенные строки, в которых встречаются все поисковые запросы.</p>
<p>Программа должна вывести все введенные строки, в которых встречаются все поисковые запросы.
Поиск не должен быть чувствителен к регистру символов.</p>
<pre class="highlight"><code class="language-code">lst = [input() for _ in range(int(input()))]
search = [input().lower() for _ in range(int(input()))]
for s in lst:
    s_lower = s.lower()
    for s1 in search:
        if s1 not in s_lower:
            break      
    else:   
        print(s)</code></pre>
<p>Искомые строки сразу приводим к нижнему регистру. Строки, в которых ищем, нельзя сразу переводить в 
нижний регистр, поскольку они должны выводиться в исходном виде. Перевод в нижний регистр 
выполняем непосредственно перед циклом поиска. В цикле проверяется вхождение искомого слова, если
оно не найдено, то цикл завершается досрочно. Если цикл завершился без прерывания, то это значит,
что все искомые слова были найдены, и строка печатается.</p>
<hr />
<p><a name="index_entry_p_18"></a><a name="ip_address_check"></a></p>
<h1 id="ip-">Проверка IP-адреса</h1>
<p>На вход программе подается строка текста, содержащая 4 целых числа разделенных точкой. Напишите 
программу, которая определяет является ли введенная строка текста корректным ip-адресом.</p>
<p>Формат выходных данных
Программа должна вывести «ДА», если введенная строка является корректным ip-адресом, и «НЕТ» — в 
противном случае. IP-адрес является корректным, если все 4 числа находятся в диапазоне от 0 до 255 
включительно.</p>
<pre class="highlight"><code class="language-code">print('ДА' if sum(1 for i in input().split('.') if 0 &lt;= int(i) &lt;= 255) == 4 else 'НЕТ')</code></pre>
<p>Здесь мы используем <a href="../python_program_elements.html#anonymous_generator">анонимный генератор</a> 
с фильтрацией. Функция <code>sum()</code> принимает этот генератор как 
источник значений. Окончательное решение принимается с помощью условного (тернарного) оператора. </p>
<hr />
<p><a name="index_entry_p_19"></a><a name="password_strength"></a></p>
<h1 id="_15">Надежность пароля</h1>
<p>Напишите функцию, которая принимает в качестве аргумента строковое 
значение пароля password и возвращает значение <code>True</code> если пароль является надежным и <code>False</code> в 
противном случае.</p>
<p>Пароль является надежным если:</p>
<ul>
<li>его длина не менее 8 символов; </li>
<li>он содержит как минимум одну заглавную букву (верхний регистр); </li>
<li>он содержит как минимум одну строчную букву (нижний регистр);</li>
<li>он содержит хотя бы одну цифру.</li>
</ul>
<pre class="highlight"><code class="language-code">checks = [str.isupper, str.islower, str.isdigit]

def is_password_good(password):
    if len(password) &lt; 8:
        return False
    resalts = [False] * len(checks)
    for c in password:
        for i in range(len(checks)):
            resalts[i] = resalts[i] or checks[i](c)
    return sum(resalts) == len(checks)

# считываем данные
txt = input()

# вызываем функцию
print(is_password_good(txt))</code></pre>
<p>Представляем проверки отдельных символов как объекты-функции 
(также см. <a href="../python_program_elements.html#functions_first_class_objects">здесь</a>). 
При этом код становится более читабельным и расширяемым.</p>
<hr />
<p><a name="index_entry_p_20"></a><a name="merge"></a></p>
<h1 id="_16">Слияние отсортированных списков</h1>
<p>Написать функцию слияния отсортированных списков в двух вариантах:</p>
<ul>
<li>для двух списков;</li>
<li>для нескольких списков.</li>
</ul>
<p>Первый вариант:</p>
<pre class="highlight"><code class="language-code">def merge(list1, list2):
    tmp = []
    i1 = 0
    i2 = 0
    while i1 &lt; len(list1) and i2 &lt; len(list2):
        if list2[i2] &lt; list1[i1]:
            tmp.append(list2[i2])
            i2 += 1
        else:
            tmp.append(list1[i1])
            i1 += 1
    for i in range(i1, len(list1)):
        tmp.append(list1[i])
    for i in range(i2, len(list2)):
        tmp.append(list2[i])
    return tmp</code></pre>
<p>Второй вариант (простая версия, использующая функцию <code>merge</code>):</p>
<pre class="highlight"><code class="language-code">def quick_merge(lists):
    result = []
    for l in lists:
        result = merge(result, l)
    return result    

lists = [[1, 2, 3, 400], [50, 60, 700], [10, 11, 17]]

print(quick_merge(lists))</code></pre>
<pre class="highlight"><code class="language-shell">&gt;python program.py
[1, 2, 3, 10, 11, 17, 50, 60, 400, 700]</code></pre>
<p>Второй вариант, полное решение в одной функции:</p>
<pre class="highlight"><code class="language-code">def quick_merge(lists):
    result = []
    pointers = [0] * len(lists)  # указатели текущих значений списков
    i_min = 0  # индекс списка с выбранным минимальным значением
    while i_min &gt;= 0:  # i_min также используется для завершения работы
        v_min = None
        i_min = -1
        for i in range(len(lists)):
            if pointers[i] &lt; len(lists[i]):  # рассматриваем только не закончившиеся списки
                v = lists[i][pointers[i]]  # текущее значение текущего списка
                if v_min is None or v &lt; v_min:
                    v_min = v
                    i_min = i
        if i_min &gt;= 0:            
            result.append(v_min)
            pointers[i_min] += 1

    return result

# считываем данные
lists = [[int(i) for i in input().split()] for _ in range(int(input()))]

# вызываем функцию
print(*quick_merge(lists))</code></pre>
<hr />
<p><a name="index_entry_p_21"></a><a name="palindrome"></a></p>
<h1 id="_17">Палиндром</h1>
<p>Напишите функцию, которая принимает в качестве аргумента строку <code>text</code> и возвращает значение <code>True</code> 
если указанный текст является палиндромом и <code>False</code> в противном случае.
Палиндром – это строка, которая читается одинаково в обоих направлениях.
При проверке считайте большие и маленькие буквы одинаковыми, а также игнорируйте пробелы, а также 
символы <code>, . ! ? -</code>.</p>
<pre class="highlight"><code class="language-code">import re

# объявление функции
def is_palindrome(text):
    text = re.sub("[ .!?,-]", '', text).lower()
    return text == text[::-1]

# считываем данные
txt = input()

# вызываем функцию
print(is_palindrome(txt))</code></pre>
<hr />
<p><a name="index_entry_p_22"></a>
<a name="index_entry_i_6"></a></p>
<h1 id="_18">Правильная скобочная последовательность</h1>
<p>Напишите функцию, которая принимает в качестве аргумента непустую строку <code>text</code>, состоящую из 
символов <code>(</code> и <code>)</code> и возвращает значение <code>True</code> если поступившая на вход строка является правильной 
скобочной последовательностью и <code>False</code> в противном случае.
Правильной скобочной последовательностью называется строка, состоящая только из символов <code>(</code> и <code>)</code>, 
где каждой открывающей скобке найдется парная закрывающая скобка.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Было решено расширить задачу, добавив проверку различных скобок и игнорирование других символов.</p>
</div>
<pre class="highlight"><code class="language-code">op = {'(': ')', '[': ']', '{': '}'}
cl = {v: k for k, v in op.items()}

# объявление функции
def is_correct_bracket(text):
    s = []
    for c in text:
        if c in op:
            s.append(c)
        elif c in cl:
            try:
                if s.pop() != cl[c]:
                    return False
            except IndexError:
                return False
    return len(s) == 0

# считываем данные
txt = input()

# вызываем функцию
print(is_correct_bracket(txt))</code></pre>
<p>Краткое описание алгоритма. Открывающиеся скобки просто добавляются в стек. При обнаружении 
закрывающейся скобки последняя добавленная скобка извлекается из стека и проверяется на соответствие
с данной закрывающейся скобкой. Остальные символы игнорируются.</p>
<p>Поверхностное тестирование:</p>
<pre class="highlight"><code class="language-shell">&gt;echo ()[]{} | python program.py
True

&gt;echo ()[]{]} | python program.py
False

&gt;echo ()m,[]{} | python program.py
True

&gt;echo ([{()()}]{}) | python program.py
True

&gt;echo la la, la | python program.py
True</code></pre>
<hr />
<p><a name="index_entry_p_23"></a></p>
<h1 id="_19">Змеиный регистр</h1>
<p>Напишите функцию, которая принимает в качестве аргумента строку в «верблюжьем регистре» и 
преобразует его в «змеиный регистр».</p>
<pre class="highlight"><code class="language-code"># объявление функции
def convert_to_python_case(text):
    result = [[]]
    current = result[0]
    for c in text:
        if c.isupper():
            current = []
            result.append(current)
        current.append(c)
    return '_'.join([''.join(e).lower() for e in result if len(e) &gt; 0])

# считываем данные
txt = input()

# вызываем функцию
print(convert_to_python_case(txt))</code></pre>
<p>Поверхностное тестирование:</p>
<pre class="highlight"><code class="language-shell">&gt;echo ThisIsCamelCased | python program.py
this_is_camel_cased

&gt;echo thisIsCamelCased87 | python program.py
this_is_camel_cased87</code></pre>
<hr />
<p><a name="index_entry_p_24"></a></p>
<h1 id="_20">Кеширование</h1>
<p>Имеется реализованная функция <code>f(x)</code>, принимающая на вход целое число <code>x</code>, которая вычисляет 
некоторое целочисленное значение и возвращает его в качестве результата работы. Функция вычисляется 
достаточно долго, ничего не выводит на экран, не пишет в файлы и зависит только от переданного 
аргумента <code>x</code>.</p>
<p>Напишите программу, которая вычисляет значение этой функции для <code>n</code> чисел.</p>
<p><strong>Формат ввода:</strong> на первой строке находится число <code>n</code> − количество значений, на которых нужно 
посчитать функцию. После этого следует <code>n</code> строк, на каждой строке по одному целому числу.</p>
<p><strong>Формат вывода:</strong>
<code>n</code> строк, в каждой из которой результат вычисления функции на соответствующем аргументе.</p>
<p>В случае дорогостоящих вычислений, если результат вычисления полностью определяется входными 
аргументами (т.е. при одних и тех же аргументах получается один и тот же результат), применяется 
так называемая практика <em>кеширования</em> (от <em>англ.</em> cache &mdash; запас), также см. 
в <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88">Википедии</a>.</p>
<p>В нашем случае мы заведем буфер в котором будем хранить аргументы и вычисленные по ним результаты.
При очередном вычислении мы сначала выполним поиск в буфере и только в случае неудачи вызовем 
дорогостоящую функцию и пополним буфер для последующих вычислений.</p>
<pre class="highlight"><code class="language-code"># Считайте, что функция f(x) уже определена выше. Определять её отдельно не требуется.
d = {}
for _ in range(int(input())):
    x = int(input())
    if x not in d:
        d[x] = f(x)
    print(d[x])</code></pre>
<p>&nbsp;</p>
<hr />

<p style="margin-top:0px;margin-bottom:0px;text-align:right;"><a href="3_final_tasks.html" 
title="Previous: 3 Итоговые задачи"><img src="../../layout/pict/previous_page.png"/></a>

<a href="5_chess.html" title="Next: 5 Шахматы"><img 
src="../../layout/pict/next_page.png"/></a>
</p>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>
</html>
